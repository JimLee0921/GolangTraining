# Goroutine

## 概述

Goroutine 是 Go 的并发执行单元，Go语言中的goroutine就是这样一种机制，goroutine 的概念类似于线程，但
goroutine是由Go的运行时（runtime）调度和管理的。
Go程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。Go 之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。

在Go语言编程中不需要去自己写进程、线程、协程，技能包里只有一个技能–goroutine，当需要让某个任务并发执行的时候，只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。




---

## 二、Goroutine 的核心特性

| 特性             | 说明                           |
|----------------|------------------------------|
| **轻量级**        | 每个 Goroutine 初始栈仅 ~2KB，可动态扩容 |
| **由 Go 调度器管理** | 用户态调度（M:N 模型），不依赖操作系统线程      |
| **共享内存空间**     | 所有 Goroutine 共享堆内存（需同步）      |
| **通信模型**       | 通过 Channel 实现同步与通信           |
| **启动简单**       | 使用关键字 `go` 启动即可              |

Go 中没有线程池或任务调度器的复杂概念，
调度完全由 runtime 自动完成。

---

## 启动 Goroutine

### 基本语法：

```
go functionName(args...)
```

或使用匿名函数：

```
go func() {
    fmt.Println("running in goroutine")
}()
```

`go` 关键字只是告诉调度器“异步执行这个函数”，
调用立即返回，不会等待任务完成。

---

## 主 Goroutine 与子 Goroutine

* 每个 Go 程序都从一个主协程（main goroutine）开始
* 主协程退出 -> 所有子协程被立即终止
* 因此在示例或测试中，需要显式等待协程完成

示例结构：

```
func main() {
    go doSomething()
    time.Sleep(time.Second)
}
```

主协程的生命周期 = 程序生命周期。
在正式场景下应使用同步机制（如 `sync.WaitGroup`），而不是 `Sleep`。

---

## Goroutine 调度模型（GMP 模型）

Go 使用 GMP（Goroutine–Machine–Processor）模型实现调度：

| 组件    | 含义        | 作用                |
|-------|-----------|-------------------|
| **G** | Goroutine | 执行单元（栈 + 状态 + 函数） |
| **M** | Machine   | 系统线程（内核级）         |
| **P** | Processor | 逻辑调度器，负责将 G 分配给 M |

🧠 **M:N 模型：**

* 多个 Goroutine（G）由若干 P 调度到多个 M；
* P 控制并行度，数量由 `GOMAXPROCS` 决定；
* Go 调度器负责在后台动态分配和切换任务。

---

## 六、Goroutine 的栈管理

* 初始栈大小约 2KB；
* 随调用深度自动扩展（最大可达 1GB）；
* 不会出现栈溢出；
* 比操作系统线程（默认 1MB 栈）轻量上千倍。

🧠 因此 Go 可以轻松同时运行成千上万个 Goroutine。

---

## 七、Goroutine 的同步与通信

Goroutine 之间可通过两种方式协作：

| 模式             | 说明                       | 推荐程度   |
|----------------|--------------------------|--------|
| **共享内存**       | 多个 Goroutine 读写同一变量（需加锁） | ⚠️ 易出错 |
| **Channel 通信** | 通过 Channel 传递数据          | ✅ 推荐方式 |

Go 的哲学：

> “不要通过共享内存来通信，
> 而要通过通信来共享内存。”

这也是 Go 并发模型的核心。

---

## 八、常见并发控制方式

| 控制机制              | 功能         | 场景     |
|-------------------|------------|--------|
| `sync.WaitGroup`  | 等待多个协程完成   | 批处理任务  |
| `sync.Mutex`      | 互斥锁，保护共享资源 | 临界区    |
| `sync.RWMutex`    | 读写锁，提高并发性能 | 多读少写   |
| `channel`         | 同步通信       | 推荐方式   |
| `context.Context` | 管理协程生命周期   | 服务请求管理 |

🧠 这些机制可混合使用：

* `WaitGroup` 等待；
* `channel` 通信；
* `context` 取消。

---

## 九、Goroutine 的生命周期管理

1️⃣ 启动：使用 `go`
2️⃣ 运行：由调度器分配到 P/M
3️⃣ 阻塞：等待 I/O 或 Channel
4️⃣ 唤醒：事件就绪重新入队
5️⃣ 退出：函数返回或 context 取消

🧠 调度器自动管理栈扩展、切换和回收，
开发者几乎不需要手动干预。

---

## 十、Goroutine 与线程的区别

| 对比项  | Goroutine   | OS Thread |
|------|-------------|-----------|
| 创建成本 | ~2KB 栈      | ~1MB 栈    |
| 数量上限 | 数十万         | 几千        |
| 调度   | Go runtime  | 操作系统      |
| 切换开销 | 极低（用户态）     | 高（内核态）    |
| 通信方式 | Channel     | 共享内存 + 锁  |
| 同步方式 | CSP（通信顺序进程） | OS 级同步原语  |
| 适用场景 | 高并发任务       | 计算密集任务    |

🧠 Goroutine = 轻量级任务 + 自动调度。
性能远优于传统线程。

---

## 十一、Goroutine 的常见陷阱

| 问题                   | 说明                      |
|----------------------|-------------------------|
| 主协程退出过早              | 子协程未完成被强制终止             |
| 数据竞争（race condition） | 多协程同时访问共享变量             |
| 闭包变量引用错误             | for 循环中使用相同变量           |
| 无限创建协程               | 没有回收机制或退出条件             |
| 忘记同步等待               | 未使用 WaitGroup 或 channel |

🧠 可使用命令检测：

```
go run -race main.go
```

可检测竞争条件。

---

## 十二、Goroutine 的最佳实践

| 实践                    | 原则                 |
|-----------------------|--------------------|
| ✅ 使用 `WaitGroup` 等待完成 | 避免 `time.Sleep`    |
| ✅ 用 `context` 控制生命周期  | 可取消任务              |
| ✅ 限制协程数量              | 使用工作池（worker pool） |
| ✅ 用 Channel 通信        | 代替共享内存             |
| ✅ 避免死锁与资源泄漏           | 保证 Channel 正确关闭    |
| ⚠️ 不滥用匿名协程            | 保持代码可控性            |

---

## 十三、Goroutine 的调度调优参数

| 参数                       | 说明                     |
|--------------------------|------------------------|
| `runtime.GOMAXPROCS(n)`  | 设置最大并行执行线程数（默认=CPU核心数） |
| `runtime.NumGoroutine()` | 返回当前活跃 Goroutine 数     |
| `runtime.Goexit()`       | 终止当前 Goroutine（安全退出）   |
| `runtime.Gosched()`      | 主动让出 CPU 给其他 Goroutine |

🧠 在高并发系统中合理配置可显著提高吞吐量。

---

## 十四、协程的应用场景

| 场景       | 示例                    |
|----------|-----------------------|
| 网络请求并发   | 同时抓取多个 URL            |
| I/O 并行处理 | 文件读写、日志流              |
| 后台异步任务   | 定时刷新、缓存更新             |
| 服务并发     | 每个请求独立协程处理            |
| 管道式任务流   | 多 stage 流水线（pipeline） |

---

## 十五、小结

| 项目   | Goroutine 特性                  |
|------|-------------------------------|
| 启动方式 | `go func()`                   |
| 执行模型 | GMP 调度（用户态）                   |
| 栈管理  | 动态扩容，极小开销                     |
| 并发模式 | CSP（通信顺序进程）                   |
| 同步机制 | Channel / WaitGroup / Context |
| 生命周期 | 随函数返回或 context 结束             |
| 优势   | 高并发、高性能、简洁                    |
| 风险   | 数据竞争、主协程过早退出                  |

🧠 **一句话总结：**

> Goroutine 是 Go 并发的最小执行单元。
> 它让高并发编程像写顺序逻辑一样简单。


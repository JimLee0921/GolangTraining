# 映射（Map）

## 概述

映射（**Map**）是 Go 中用于存储**键值对（key-value）**的数据结构，
相当于其他语言里的字典（Python dict）、哈希表（Java HashMap）、对象字典（JavaScript Object）。

键不能重复值可以重复并且内部元素是无序的，
Go 的 map 底层是 哈希表，元素的位置由哈希函数决定，
遍历 map (for range) 时，顺序是随机的，
每次运行，甚至同一次运行中的不同遍历，顺序都可能不同。

它是一种引用类型（Reference Type），
提供 **O(1)** 平均时间复杂度的查找、插入和删除操作。



---

## 声明与初始化

* 键（Key）必须可比较
* 值（Value）类型任意
* 无固定顺序（每次遍历顺序可能不同）

定于语法：`map[KeyType]ValueType`

* `map[string]int` -> 键为字符串，值为整数；
* `map[int]string` -> 键为整数，值为字符串。

### 使用 var 创建 nil map

可以使用 var 创建一个 nil map：`var m map[KeyType]ValueType`， 但是只能读不能写

### make 创建

`make(map[KeyType]ValueType, hintSize)`：可立即读写但不能初始化

KeyType：键的类型（必须是可比较的类型，比如 string、int、bool）
ValueType：值的类型（任意类型）
hintSize（可选）：初始容量提示，大概需要多少空间

### 字面量创建

`map[KeyType]ValueType{}`：最常用，可立即读写且初始化
可选择传入初始化值，如果不传入也不是 nil map，而是一个空 map

### 键定义类型要求

键（key）必须是**可比较类型**，即支持 `==` 运算。

**可用作键的类型：**

* 基础类型：`string`, `int`, `bool`, `float`, `rune`, `byte`
* 指针、通道、接口类型
* 只包含可比较字段的结构体、数组

**不可用作键的类型：**

* 切片（slice）
* Map（map）
* 函数（func）

**原因：**
这些类型无法定义稳定的哈希值或等价关系。

---

## 类型特征

| 特性    | 说明                |
|-------|-------------------|
| 类型    | 引用类型              |
| 内部实现  | 哈希表（hash buckets） |
| 键类型要求 | 可比较（支持 `==` 运算）   |
| 值类型   | 任意（包含复合类型）        |
| 动态增长  | 自动扩容              |
| 无序    | 不保证遍历顺序一致         |
| 零值    | `nil`（不可直接赋值）     |

---

## 基本操作

| 操作      | 语法                | 说明            |
|---------|-------------------|---------------|
| 读取      | `v := m[key]`     | 若不存在，返回值类型的零值 |
| 检查键存在   | `v, ok := m[key]` | 若存在，`ok=true` |
| 插入 / 更新 | `m[key] = value`  | 若键存在则更新       |
| 删除      | `delete(m, key)`  | 若键不存在则无影响     |
| 获取长度    | `len(m)`          | 当前键值对数量       |

### 下标读取

访问 map 元素：直接通过键访问获取值，如果 key 不存在则返回 value 类型的零值

`value, ok = map[key]`
返回值:

- value：key 对应的值
- ok：可选接收返回值，主要区分零值和key不存在的情况

> 不存在的键返回零值，需要使用 `ok` 模式判断键存在性

### 添加更新元素

map 添加元素直接通过赋值语句即可：`map[key] = value`

- 如果 key 不存在，就是新增
- 如果 key 存在会覆盖原来的值，相当于更新

> 注意如果 map 是 nil map，直接赋值会 panic

### 删除元素

map 删除元素使用 delete 内置函数，直接修改原 map： `delete(map, key)`

- map：需要操作删除的 map
- key：要删除的键
- 如果 key 不存在，delete 什么都不会做，也不会报错，方法没有返回值
- 可以对 `nil` Map 调用 `delete` 是安全的
- 删除操作不会立即回收内存（延迟由 GC 管理）

> 可以使用 `value, ok = map[key]` 先做是否存在的判断再进行安全删除

### 获取长度

可以使用 len() 函数查询 map 长度：`len(map)`

### 遍历

使用 `for range` 进行 map 的遍历，返回 key 和 value

```
for key, value := range map {
    fmt.Println(key, value)
}
```

* 遍历顺序随机，每次迭代顺序可能不同，同一数据在不同运行中顺序也可能变化
* 仅遍历键：`for k := range m {}`
* 遍历期间可删除当前键
* 遍历期间写入可能导致不可预期行为（不推荐）

> 进行排序：取出所有键 -> 对键进行排序 -> 再按序访问

---

## 值语义与引用语义

| 特征       | Map                  |
|----------|----------------------|
| 类型       | 引用类型                 |
| 拷贝行为     | 拷贝 Map 头部（引用同一底层哈希表） |
| 修改效果     | 共享底层结构，彼此影响          |
| `nil` 检查 | 可使用 `if m == nil` 判断 |

> Map 赋值不会复制键值内容，只复制指针
> 多个变量指向同一底层结构，修改彼此可见

---

## Map 的性能与底层实现

### 底层结构

Go 的 Map 是基于 哈希表（hash table） 实现，内部包含：

* **桶（bucket）**：存放键值对
* **哈希函数**：计算键的存储位置
* **渐进式扩容**：按需动态分裂桶
* **随机化哈希种子**：防止哈希攻击

### 性能特征

| 操作 | 时间复杂度   | 说明    |
|----|---------|-------|
| 读取 | O(1) 平均 | 哈希定位  |
| 插入 | O(1) 平均 | 自动扩容  |
| 删除 | O(1) 平均 | 桶标记删除 |
| 遍历 | O(n)    | 顺序随机  |

优化建议：

* 预估元素数量，使用 `make(map[T]U, n)`
* 尽量避免在遍历时修改 Map
* 对高频访问键使用短字符串或整数以提高哈希效率

### 线程安全性

普通 Map 不是并发安全的，多个 goroutine 同时写入会导致运行时 panic
解决方案：

1. 使用锁（`sync.Mutex` / `sync.RWMutex`）
2. 使用 `sync.Map`（并发安全 Map）
    * 内部分段 + 无锁读优化
    * 性能在高并发场景更优
    * 不支持普通 `map` 的语法糖

---

## 使用场景

| 场景   | 说明                 |
|------|--------------------|
| 频繁查找 | 快速根据键取值（如缓存）       |
| 数据聚合 | 统计、计数、分组           |
| 索引映射 | ID -> 对象、名称 -> 结构体 |
| 去重处理 | 通过键存在性实现集合         |
| 动态配置 | 以键值结构描述配置项         |

---

## 限制与陷阱

| 陷阱         | 原因与说明                |
|------------|----------------------|
| 遍历顺序不稳定    | Map 无序               |
| 写入 nil Map | 运行时 panic            |
| 并发写入       | 非线程安全                |
| 不可比较       | 不能直接 `==` 比较（除与 nil） |
| 值共享        | 拷贝 Map 时共享底层结构       |






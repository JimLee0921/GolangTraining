# 切片（Slice）

## 概述

切片（Slice）是 Go 中最常用的数据结构，切片其实就是对数组的一个引用视图，底层依然是数组，
和数组不同，切片的长度可以变化（动态扩展/缩减），
切片比数组更灵活，因此实际开发中用切片远多于数组，
并且切片和数组中的元素都是可以重复的。

可以理解为：

> 切片是一个轻量级的结构体
> 指向一段数组的底层存储空间

与数组不同：

* 数组长度固定
* 切片长度可变
* 切片是引用类型（多个切片可共享同一底层数组）

---

## 切片的结构组成

每个切片底层由三部分组成（称为三元组）

| 字段    | 含义                   |
|-------|----------------------|
| `ptr` | 指向底层数组的指针起始位置        |
| `len` | 当前切片的长度（可访问的元素数量）    |
| `cap` | 容量（从起始位置到底层数组末尾的元素数） |

总是有 0 ≤ len(s) ≤ cap(s)

扩容大致规则：

* 若 `len < cap`，直接扩展
* 若超出容量，则创建新的底层数组，Go 会分配一个新的底层数组，并复制原有数据
* 扩容通常按 **2 倍策略** 增长（但不是固定）

```
底层数组： [0][1][2][3][4][5][6]
切片 s  ：     ↑------ len=3
                ↑------------- cap=5
```

---

## 切片的创建方式

### 直接声明（零值）

`var s []int`

* 初始值为 `nil`
* `len(s) == 0`，`cap(s) == 0`

### 使用内置函数 `make`

make 内置函数用来创建并初始化 slice、map、chan 这三种引用类型，
对于切片（slice），make 会 分配底层数组，并返回一个切片对象，

语法：`make([]Type, len, cap)`：

- len：切片的长度（初始化后能直接用下标访问的元素个数）
- cap：切片的容量（底层数组大小）

规则：必须满足 0 <= len <= cap

- 只指定 len 时 len = cap
- 如果 len > cap，会直接编译报错
- 如果 len == cap，切片刚好占满底层数组
- 如果 len < cap，切片“预留”了一些空间，方便后续 append
- 省略 cap 时，cap = len
- len=0 但 cap>0 时，切片为空，但有预留容量，只有在 0 <= index < len(slice) 时，下标赋值才合法

`s := make([]int, 3, 5)`

* 创建长度为 3、容量为 5 的切片
* 底层自动分配数组
* 常用于预分配内存的场景

### 通过字面量初始化

`s := []string{"Go", "Rust", "C"}`

* 同时创建切片与底层数组
* 最常见的写法

### 切片表达式

切片表达式可以从数组或切片里截取一段子切片，但是子切片修改会影响原数组或切片因为子切片和原切片或数组共享底层存储

#### 普通切片表达式：

s[low : high]（结果是一个新的切片）

- low：起始索引（包含），省略就是 0 开始
- high：结束索引（不包含），省略就是到 len(s)
- 结果切片的：
    - 长度 = high - low
    - 容量 = cap(s) - low

#### 全切片表达式

s[low : high : max]（返回的也是一个新的切片）

- low：起始索引（包含）
- high：结束索引（不包含）
- max：容量上限（不包含）
- 结果切片的：
    - 长度 = high - low
    - 容量 = max - low

全切片表达式是为了：

1. 控制容量：限制新切片的可用容量，避免影响原切片后续的数据
2. 防止 append 时覆盖原数据
3. 但并不是彻底独立拷贝，它依然共享底层数组，只是 容量(cap) 被限制了

---

## 切片的核心特性

| 特性        | 说明                        |
|-----------|---------------------------|
| 引用类型      | 多个切片可指向同一底层数组             |
| 长度可变      | 可通过 `append` 动态增加         |
| 共享内存      | 子切片与原切片共享数据               |
| 自动扩容      | 超出容量时会创建新的底层数组            |
| 零值为 `nil` | 可安全使用（如 `append(nil, x)`） |

---

## 切片的零值与 nil 切片

| 切片类型         | `len` | `cap` | `nil` 判定 | 可用性          |
|--------------|-------|-------|----------|--------------|
| 未初始化         | 0     | 0     | true     | 可安全 `append` |
| 空切片（`[]T{}`） | 0     | 0     | false    | 等价可用         |
| 非空切片         | >0    | ≥len  | false    | 正常使用         |

> `nil` 切片与空切片行为相似，但在底层内存不同

---

## 常用内置函数

### 图览

| 函数                    | 功能   | 说明       |
|-----------------------|------|----------|
| `append(s, x...)`     | 追加元素 | 若超容量则扩容  |
| `copy(dst, src)`      | 复制内容 | 返回复制的元素数 |
| `len(s)`              | 获取长度 | 当前元素数量   |
| `cap(s)`              | 获取容量 | 最大容量     |
| `make([]T, len, cap)` | 创建切片 | 初始化指定容量  |

### 切片展开式

`slice...` 切片展开语法（slice expansion），
主要用在 函数调用（可变参数函数） 或 append（拼接切片） 里

---

## 切片拷贝

### 浅拷贝（直接赋值）

因为切片共享底层数组，所以直接赋值时不会产生真正的拷贝，
切片的赋值本质上是浅拷贝，所以直接赋值当一个切片被修改另外一个也会被修改

### 深拷贝（copy函数）

Go 提供了内置函数 copy，用来把一个切片的元素复制到另一个切片中。
copy 函数会创建新的底层数组，两个切片互不影响。

使用 copy 函数：copy(dst, src)

- 只会拷贝到目标切片已有的长度部分，不会自动扩容，所以必须 dst 需要指定长度
- 返回值是实际复制的元素个数 = min(len(dst), len(src))
- dst 必须是一个切片（slice），而且 要有足够的长度（len）来容纳元素
- 新切片的容量不需要关注，但是如果 len 为 0 则什么都不会拷贝

### 使用 append 进行深拷贝

clone := append([]T(), src...)

- append 会自动分配足够的空间，写法简洁，不容易出错
- []T()： 表示一个 nil 切片，类型是 []T，它没有底层数组，长度和容量都是 0
- `src...`：... 是 切片展开（unpack）语法，把 src 切片里的每个元素依次作为 append 的参数

> append 用于把元素追加到一个新切片里，
> 因为最开始的切片是 []T()，里面没有元素，容量为 0，所以 append 时必须分配新的底层数组，
> 这样一来，新切片的底层数组和 src 的底层数组完全不同

---

## 添加元素

### 使用 append 方法进行元素添加

使用 append 触发扩容时方法会返回一个新的切片需要接收（长度和容量都会变化），
扩容策略是实现细节，容量不够会分配更大数组并复制旧数据，append 返回的新切片必须要接回变量，
切片的容量扩容规则不是固定翻倍，而是由底层实现（runtime）决定的，跟当前容量和需要的大小有关。

1. append 默认在末尾进行插入一个或多个元素

   `s = append(s, newElements) // newElements 是可以同时插入多个元素`

2. append 开头插入一个或多个元素

   `s = append([]type{newElements}, s...)`
    - 思路：先把新元素放前面，再拼接原切片：

3. append 两次拼接在中间插入一个或多个元素

   `s = append(s[:i], append([]type{newElements}, s[i:]...)...)`
    - s[:i] -> 插入点之前的部分
    - []type{newElements} -> 要插入的元素
    - s[i:] -> 插入点及之后的部分

4. copy 中间插入一个或多个元素（手动使用 append 添加切片长度）
    ```
    newVals := []type{newElements} // 要插入的多个元素
    s = append(s, 0)              // 扩展一位，这里是补一个类型的空值即可，string就是 ""
    copy(s[i+1:], s[i:])          // 后半部分整体向后移动
    s[i] = 99                     // 插入新值
    fmt.Println(s) // [1 2 99 3 4]
    ```
    - 特点： 只申请一次 append 的扩容，更高效，适合频繁插入

### 切片的扩容机制

扩容规则大致是：

- 如果 append 后的长度小于等于 原来容量的 2 倍，通常就直接 翻倍
- 如果 append 后的长度大于 2 倍容量，就会直接扩容到所需长度
- 当切片容量比较大时（比如 >1024），扩容增量会逐渐变小（不是严格翻倍，而是接近 1.25 倍）
- 若容量不足，Go 自动分配更大的底层数组，旧元素复制到新数组，原切片与新切片不再共享内存

---

## 删除元素

删除元素（需要删除指定元素需要使用 for range 进行遍历判断），
Go 中需要用 切片拼接 或 copy 来实现删除切片元素

1. 删除下标为 i 到 j 的元素（最常用，j = i +1 则就是只删除下标为 i 的元素）
    - s = append(s[:i], s[j:]...) -> i < j
    - s[:i] -> 要保留的前半部分
    - s[j:] -> 要保留的后半部分
    - 拼接在一起就相当于跳过了下标为 i 到 j 的元素，注意不包含下标为 j 的元素

2. 删除开头或结尾元素
    - 删除开头元素：s = s[i:] 直接把切片向右偏移 i 格，也就是舍弃前 i 个元素
    - 删除结尾元素：s = s[:len(s)-i] 直接把切片截断去除后 i 个元素

3. 使用 copy 删除多个元素（更高效）
    - copy(s[i:], s[j:])    -> i < j
    - 把 s[j:] 挪到 s[i:]，覆盖掉要删除的部分
    - s = s[:len(s)-(j-i)]
    - 缩短切片长度，删除的就是从 i 到 j 的元素

---

## 比较与遍历

| 操作          | 说明               |
|-------------|------------------|
| `==` / `!=` | 仅可与 `nil` 比较     |
| 遍历          | 可使用 `for range`  |
| `range` 行为  | 遍历时复制切片头，不复制底层数组 |

若需比较内容，可使用：

* `reflect.DeepEqual(s1, s2)`
* 或循环逐元素比较

---

## 数组的对比

| 特征   | 数组（Array） | 切片（Slice）       |
|------|-----------|-----------------|
| 长度   | 固定        | 动态可变            |
| 类型定义 | `[N]T`    | `[]T`           |
| 内存分配 | 栈上（小）或堆上  | 自动管理            |
| 值/引用 | 值类型       | 引用类型            |
| 拷贝   | 拷贝整个数组    | 拷贝引用头           |
| 可扩展性 | 否         | 可通过 `append` 扩容 |
| 使用频率 | 较低        | 极高（Go 集合核心）     |



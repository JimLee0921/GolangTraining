# 结构体（Struct）

## 概述

结构体（**struct**）是 Go 中用于聚合多个字段（field）的复合数据类型（数据模型基础单元）。
它相当于一种自定义的数据容器，
可以把不同类型的变量组织为一个整体，组合多个字段形成新的类型，用于建模实体对象。



---

## 结构体的特性

| 特性    | 说明                         |
|-------|----------------------------|
| 类型    | 值类型（value type）            |
| 组成    | 多个字段（name:type）组合          |
| 内存    | 字段顺序决定内存布局                 |
| 零值    | 每个字段自动初始化为零值               |
| 可比较性  | 若所有字段可比较，则结构体整体可比较         |
| 不支持继承 | Go 通过**组合（embedding）**实现复用 |

---

## 结构体的定义与类型声明

结构体通过 `type` 关键字定义，字段可以是不同类型

**命名惯例：**

* 类型名首字母大写 -> 可导出（跨包访问）
* 字段首字母大写 -> 公有字段
* 字段首字母小写 -> 包内私有

```
type StructName struct {
    Field1 Type1
    Field2 Type2
    ...
}
```

### 普通结构体变量初始化

#### 零值初始化

语法：`var instance StructName`

- 得到的是 struct 的零值 = 每个字段取该类型的零值（数值 0、布尔 false、string ""、指针 nil 等）
- 零值可用，不会是未初始化状态。

#### 指定字段初始化(推荐)

语法：`instance := StructName{field1: value1, field2: value2}`

- 字段可缺省，缺省部分取零值
- 推荐写法，安全、可读性好

#### 按字段顺序

语法：`instance := StructName{value1, value2, ...}`

- 必须提供所有字段
- 不推荐，字段顺序变动会出现问题

### 匿名结构体

匿名结构体就是没有名字的 struct 类型，它在定义的同时直接使用，不需要先写 `type StructName struct { ... }`

- 临时使用一次的结构体，不需要提前 type 定义
- 可以只声明不初始化
- 如果匿名结构体的字段名、顺序、类型、tag 都完全一致，那么它们就是同一个类型，可以互相赋值
- 但是即使字段都相同但是顺序不一样也不能赋值

使用场景

- 一次性使用的数据组合：例如某个函数里临时需要把几个字段打包，不想额外定义新类型
- 快速 mock 数据：写测试、演示代码时，用匿名结构体省事
- 返回多个字段：如果不想写命名结构体，可以用匿名结构体作为返回值

### 结构体指针

在 Go 中，结构体指针（pointer to struct）是很常见的用法，本质上就是存放结构体地址的变量：
`pointInstance := &StructName{初始化属性}`

- pointInstance 是 *structType 类型 指向一个 structType
- Go 做了语法糖：访问字段时 不需要写 (*instance).字段名，直接写 p.字段名 就行

#### 创建结构体指针

1. 取地址符 &T{...}
   使用 复合字面量 (composite literal) 创建结构体，并立刻取地址
   得到的类型是 *T（指针）
   可以指定字段

2. 使用 new 关键字（不常用，但等价）
   new(T) 会分配一块内存，把所有字段置为 零值，返回 *T
   没法像 &T{...} 那样直接指定初始字段值，只能先得到零值，再去赋值

---

## 常见操作

### 字段访问与更新

可以直接直接通过 .属性名 访问和修改属性值

* 访问字段：`u.Name`
* 修改字段：`u.Age = 30`
* 指针结构体自动解引用：`p.Name` 等价于 `(*p).Name`

**值语义：**

> 结构体是值类型，赋值时会复制所有字段内容。
> 若需共享，使用结构体指针。

### 结构体比较与赋值

| 操作          | 说明           |
|-------------|--------------|
| `==` / `!=` | 仅当所有字段可比较时可用 |
| 赋值          | 值拷贝（字段逐一复制）  |
| 指针赋值        | 指向同一对象（引用语义） |

示意：

```
a := User{"Tom", 20, true}
b := a     // 拷贝
b.Name = "Jerry"
// a.Name 仍为 "Tom"
```

---

## 匿名字段与嵌入（Embedding）

在 Go 里，嵌入 (embedding) 就是把一个类型（通常是 struct）直接写在另一个 struct 里，而不给它起字段名，
类似于继承但不是继承。

- 传统 OOP 里的继承（Java/C++）：子类自动拥有父类的字段和方法，支持多态、重写（override）、继承链
- Go 的 struct 嵌入
    - 并不是继承，而是把一个类型嵌入到另一个类型里
    - 嵌入类型的 字段和方法会提升 (promotion)，可以像直接属于外层 struct 一样访问
    - Go 没有继承链，强调的是 组合优于继承

Go 支持在结构体中嵌入其他结构体或类型，称为匿名字段或嵌入结构体，这是 Go 实现组合优于继承的机制。

### 示例

示例结构（逻辑）：

```
type Base struct {
    ID int
}

type User struct {
    Base
    Name string
}
```

**效果：**

* 可直接访问嵌入字段：`u.ID`
* 相当于“字段提升（field promotion）
* 类似继承，但仅是语法糖，无层级关系

---

### 嵌入的规则与行为

| 特性   | 说明                    |
|------|-----------------------|
| 字段提升 | 可直接通过外层访问内层字段         |
| 命名冲突 | 外层字段会遮蔽同名内层字段         |
| 多重嵌入 | 可多层嵌入（形成平铺字段）         |
| 方法提升 | 内层结构体的方法也可被提升（用于接口实现） |

嵌入 struct 的字段和方法会提升，可以像直接属于外层一样访问，
但如果外层定义了一个同名字段，它会遮蔽 (shadow) 内层的字段，
内层字段或方法仍然存在，只是要通过完整路径（u1.Base.ID）才能访问。


--- 

## 方法绑定

> 更多见 reference-types/methods 章节

在 Go 中，方法（method）其实就是一种特殊的函数，它绑定（bind）到某个类型上。

定义语法如下：

```
func (接收者 receiver) 方法名(参数列表) 返回值列表 {
    // 方法体
}
```

这时就可以直接通过实例调用： `r.方法名`

### 接收者类型（Receiver Type）

Go 的方法接收者有两种形式：

#### 值接收者（Value Receiver）

```
func (u User) Greet() {
    fmt.Println("Hello,", u.Name)
}
```

特征：

* 传入时会复制整个结构体
* 在方法内部修改字段，不会影响外部原值
* 调用时可以用值或指针调用（Go 会自动解引用）
* 主要用于只获取其属性，而不进行修改

#### 指针接收者（Pointer Receiver）

```
func (u *User) GrowUp() {
    u.Age += 1
}
```

特征：

* 方法接收的是结构体指针
* 可以在方法内修改原结构体，适用于需要修改其字段时
* 适合结构体较大或需要修改字段的情况
* 调用时同样支持值或指针（Go 自动取地址）

### 函数与方法

| 函数                   | 方法                                      |
|----------------------|-----------------------------------------|
| `func FuncName(...)` | `func (r ReceiverType) MethodName(...)` |
| 不属于任何类型              | 绑定到某个类型（值类型或指针类型）                       |
| 调用：`FuncName()`      | 调用：`变量.MethodName()`                    |

```text
type person struct {
    name string
    age int
}

// 方法值接收者
func (p person) SetAgeOne(age int) {
	p.age = age
}

// 方法指针接收者
func (p *person) SetAgeTwo(age int) {
	p.age = age
}

// 函数指针接收者
func setAgeThree(p *person, age int) {
	p.age = age
}

// 函数值接收者
func setAgeFour(p person, age int) {
	p.age = age
}
```

上述四个方法都可以用于修改 person 实例的 age 属性，但是调用和具体操作结果上不同：

| 编号    | 定义类型      | 调用示例                  | 是否自动取址                     | 是否能修改原对象 | 语法风格  | 是否可绑定接口 |
|-------|-----------|-----------------------|----------------------------|----------|-------|---------|
| one   | 方法（值接收者）  | `p.SetAgeOne(30)`     | 否（传副本）                     | 否（改副本）   | 面向对象式 | 可以-值方法  |
| two   | 方法（指针接收者） | `p.SetAgeTwo(30)`     | 自动取地址 (`(&p).SetAgeTwo()`) | 可以       | 面向对象式 | 可以-指针方法 |
| three | 函数（指针参数）  | `setAgeThree(&p, 30)` | 必须手动传指针                    | 可以       | 函数式   | 不能      |
| four  | 函数（指针参数）  | `setAgeFour(p, 30)`   | 否（传副本）                     | 否        | 函数式   | 不能      |

- 对于结构体操作来说需要修改结构体字段时使用方法指针接收者
- 对于结构体操作来说只需要读，不需要修改时使用使用方法值接收者

#### 自动取址 / 解引用规则

解引用就是把指针指向的值取出来，在 Go 中用 `*` 操作符完成

自动取址（更准确叫 auto-addressing）是 Go 编译器的语法糖，当调用一个指针接收者方法时，它会自动帮你加上取地址符 `&`

方法调用（带点号）会触发自动取址 / 解引用

Go 对方法调用做了自动转换（method set promotion）

## 结构体与接口

结构体是实现接口的主要载体。
只要结构体定义了接口要求的方法，就自动实现该接口，无需显式声明。

*特征：**

* 无需关键字 `implements`
* 多个结构体可实现同一接口
* 可通过接口参数实现多态

### 方法集合（Method Set）规则

Go 定义了方法集合的概念，即某个类型上可以访问哪些方法：

| 类型       | 它的方法集合包含哪些方法      |
|----------|-------------------|
| T（非指针类型） | 所有接收者是 T 的方法      |
| *T（指针类型） | 所有接收者是 T 和 *T 的方法 |

也就是说：

* 值类型只能直接调用值接收者方法
* 指针类型可以调用两种方法

> 方法集合在 interface 接口中再进行详细讲解


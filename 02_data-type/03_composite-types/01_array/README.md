# 数组（Array）

## 概述

数组（**Array**）是 Go 中最基础的复合数据结构之一。
它用于存放**固定数量、相同类型**的元素。
数组在内存中是一段**连续空间**，每个元素的类型相同且占用固定大小。

**关键特征：**

* 长度固定（定义时确定）
* 元素类型一致
* 值类型（赋值会复制整个数组）
* 支持索引访问（从 0 开始）

---

## 语法结构

数组的定义形式为：

```
[长度]类型
```

* `[5]int`：包含 5 个整数的数组
* `[3]string`：包含 3 个字符串的数组

数组的**长度是类型的一部分**，
即 `[3]int` 和 `[4]int` 是两种不同的类型。

---

## 数组的性质

| 特性    | 说明               |
|-------|------------------|
| 类型固定  | 元素类型在定义时确定       |
| 长度固定  | 不能动态扩展           |
| 值类型   | 赋值或传参时会复制全部元素    |
| 内存连续  | 元素按顺序紧挨存储，性能可预测  |
| 零值初始化 | 所有元素自动初始化为该类型的零值 |

---

## 数组的声明方式

**显式声明**

```
var arr [3]int
```

自动初始化为 `[0, 0, 0]`

**初始化时赋值**

```
var nums = [3]int{1, 2, 3}
```

**自动推断长度**

```
names := [...]string{"Go", "Rust", "C"}
```

**按索引初始化**

```
scores := [5]int{0: 100, 3: 60}
```

-> `[100, 0, 0, 60, 0]`

**多维数组**

可以使用 `[m][n]T` 形式定义多维数组

```
var matrix [2][3]int
matrix[0] = [3]int{1, 2, 3}
matrix[1] = [3]int{4, 5, 6}

fmt.Println(matrix)
fmt.Println(matrix[0][1]) // 访问第 1 行第 2 列
```

---

## 数组的访问特性

* 元素通过下标访问：`arr[i]`
* 下标从 `0` 到 `len(arr)-1`
* 超出索引范围会引发 **panic**

| 函数         | 作用           |
|------------|--------------|
| `len(arr)` | 返回数组长度       |
| `cap(arr)` | 返回数组容量（等于长度） |

---

## 数组的值语义

数组是 **值类型（Value Type）**，
赋值或传入函数时会**复制整个数组**：

```
a := [3]int{1, 2, 3}
b := a // 复制独立副本
```

**关键理解：**

* `b` 的修改不会影响 `a`
* 这与「切片（Slice）」不同，切片是引用类型

这种行为保证了**内存安全与确定性**，
但在性能敏感场景中需谨慎使用大数组。

---

## 数组与切片的关系

* 切片（Slice）是对数组的动态视图
* 数组是切片的底层存储
* 可通过切片语法 `arr[start:end]` 获取数组的部分视图

```
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:4] // 切片引用 [2,3,4]
```

此时 `s` 共享 `arr` 的底层存储空间，修改 `s` 会影响 `arr`

---

## 数组的比较与遍历

| 操作          | 说明                 |
|-------------|--------------------|
| `==` / `!=` | 可比较：当两个数组长度与元素类型相同 |
| `range`     | 可遍历元素及索引           |
| `_`         | 可忽略索引或值            |

Go 不允许不同长度或不同类型的数组直接比较

---

## 数组的内存模型

| 特性   | 说明          |
|------|-------------|
| 连续内存 | 元素顺序排列，缓存友好 |
| 固定容量 | 一经定义不可扩容    |
| 拷贝语义 | 赋值时复制整个内存块  |
| 零值填充 | 声明时自动初始化    |

* 小数组适合直接使用
* 大型数组建议通过切片传递以避免复制

---

## 数组的遍历

`range` 遍历数组时，会复制整个数组（值传递）
因此通常更推荐遍历数组的指针或切片视图

```
for i, v := range arr {
    ...
}
```

此处 `v` 是值拷贝，`i` 是索引

---

## 数组与函数

* 函数参数若为数组，会传入副本
* 若希望共享数据，应传递指针或切片
* 数组可与 `const` 一起构建编译期固定表（如查表算法）

---

## 数组与零值

数组的每个元素都自动初始化为其类型的零值。

* `[3]int` -> `[0, 0, 0]`
* `[2]string` -> `["", ""]`
* `[4]bool` -> `[false, false, false, false]`

---

## 小结

| 特性    | 数组（Array）              |
|-------|------------------------|
| 类型定义  | `[N]T`（长度为 N 的 T 类型数组） |
| 值语义   | 拷贝赋值，独立副本              |
| 内存结构  | 连续存储                   |
| 长度固定  | 不可动态改变                 |
| 可比较性  | 长度与类型相同可比较             |
| 与切片关系 | 切片基于数组实现               |
| 常用场景  | 固定数据、底层结构、静态表          |

> 数组是 Go 内存模型的基石
> 它提供了固定长度、强类型、连续存储的高性能结构
> 同时也是切片（Slice）的底层支撑


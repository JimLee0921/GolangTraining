# 复合类型（Composite Types）

## 概述

在 Go 中，复合类型（Composite Types）是由基础类型组合而成的结构化类型。
它们用于表示一组值、键值对或自定义的复杂数据结构。

Go 的复合类型主要包括：

| 类型              | 关键特征       | 典型用途         |
|-----------------|------------|--------------|
| **数组（Array）**   | 固定长度、值类型   | 小规模数据、底层内存操作 |
| **切片（Slice）**   | 动态长度、引用类型  | 动态集合、列表操作    |
| **映射（Map）**     | 无序键值对      | 快速查找、数据关联    |
| **结构体（Struct）** | 聚合字段的自定义类型 | 数据建模、对象定义    |

---

## 类型层次结构

Go 的类型系统可从下往上理解为：

```
Primitive Types   ->   Composite Types   ->   Reference / Interface Types
(值)              ->   (数据结构)       ->   (行为与引用)
```

复合类型在此处承担连接桥梁的作用：

* 它们依托基础类型（如 int、string）
* 同时为后续的接口和方法提供数据结构基础

---

## 数组（Array）

### 概念

* 固定长度、元素类型相同；
* 长度是类型定义的一部分；
* 存储在连续内存中；
* **值类型**（赋值会拷贝整个数组）。

### 特点

* 适合静态、固定数据；
* 用作切片（slice）的底层基础；
* 很少单独使用（多数通过切片访问）。

### 示例概念

`var a [3]int = [3]int{1, 2, 3}`：存储类型为 int 长度为3 元素为 1, 2, 3 的数组

`b := [...]string{"Go", "Rust", "C"}`：自动推断长度，类型为 string，元素为 Go Rust C 的数组

---

## 切片（Slice）

### 概念

* 动态长度的数组视图
* 底层结构包含：
    * 指向数组的指针
    * 长度（len）
    * 容量（cap）

### 特征

* **引用类型**（共享底层数组）
* 可动态扩容
* 使用最广泛的集合类型
* 创建方式：字面量、切片表达式、`make()`

### 操作概念

* `append()` 添加元素
* `copy()` 复制内容
* `len()` / `cap()` 获取长度与容量
* 切片截取：`s[low:high]`

### 应用场景

* 列表、栈、队列、动态数组
* 常用于 JSON 解析、集合处理、数据批量传输

---

## 映射（Map）

### 概念

* 无序的键值对集合
* 类似字典（dictionary）
* 使用哈希表实现
* **引用类型**

### 特征

* 键（key）必须可比较
* 值（value）类型任意
* 非线程安全（需锁或 sync.Map）

### 常用操作

* 访问：`m[key]`
* 插入 / 修改：`m[key] = value`
* 删除：`delete(m, key)`
* 判断存在性：`v, ok := m[key]`

### 应用场景

* 配置表、索引缓存、快速查找；
* 作为结构体内嵌字段实现灵活映射。

---

## 结构体（Struct）

### 概念

* 一组字段（field）的组合；
* 每个字段有名称与类型；
* 类似「对象」的最小原型；
* Go 的核心数据建模方式。

### 特征

* **值类型**；
* 字段可嵌套（支持匿名嵌入）；
* 可通过方法（receiver）绑定行为；
* 是接口实现与面向组合设计的基础。

### 应用场景

* 数据模型（如用户、订单、配置）；
* 封装业务实体；
* 构建复杂系统的数据骨架。

---

## 值类型 vs 引用类型（在复合类型中）

| 类型          | 值/引用 | 拷贝行为             |
|-------------|------|------------------|
| 数组（Array）   | 值类型  | 赋值会复制整个数组        |
| 切片（Slice）   | 引用类型 | 赋值仅复制指针、len、cap  |
| 映射（Map）     | 引用类型 | 多变量共享底层哈希表       |
| 结构体（Struct） | 值类型  | 字段逐一复制（除非包含引用字段） |

**结论：**

* 数组、结构体传值会产生独立副本
* 切片、Map 传值仍共享底层数据
* 函数参数传递时，需清楚值语义 vs 引用语义

---

## 内置函数的适用性

| 函数         | 作用      | 适用于                   |
|------------|---------|-----------------------|
| `len()`    | 获取长度    | 数组、切片、字符串、Map、channel |
| `cap()`    | 获取容量    | 数组、切片、channel         |
| `make()`   | 创建引用类型  | 切片、Map、channel        |
| `new()`    | 分配零值指针  | 任意类型（返回指针）            |
| `append()` | 向切片追加元素 | 切片                    |
| `copy()`   | 复制元素    | 切片                    |
| `delete()` | 删除键     | Map                   |

---

## 内存模型与共享机制

| 特性    | 数组  | 切片         | Map    | Struct   |
|-------|-----|------------|--------|----------|
| 内存连续性 | ✅ 是 | ✅ 部分（底层数组） | ❌ 哈希分布 | ✅ 按字段顺序  |
| 动态增长  | ❌   | ✅ 自动扩容     | ✅ 动态分配 | ❌ 固定字段   |
| 引用共享  | ❌   | ✅          | ✅      | 取决于字段类型  |
| 线程安全  | ✅   | ❌          | ❌      | ✅（值传递安全） |

**重点理解：**

* 切片是数组的窗口，操作切片常常影响原数组
* Map 是指针包装的哈希结构
* Struct 是组合语义的最小单元

---

## 组合（Composition）理念

Go 不支持类继承（class inheritance），
但支持结构体嵌入（embedding），实现组合优于继承的设计哲学。

**组合的意义：**

* 复用结构与行为
* 减少继承层级
* 通过接口与嵌入实现多态

| 类型     | 编程抽象   | 典型使用场景        |
|--------|--------|---------------|
| 数组     | 固定数据容器 | 底层算法、内存优化     |
| 切片     | 动态序列   | 数据批处理、集合管理    |
| Map    | 键值存储   | 缓存、索引、快速查找    |
| Struct | 数据模型   | 实体建模、API 数据结构 |

> Go 的复合类型用来组合构造复杂数据结构，
> 而不是用继承组织层级关系。

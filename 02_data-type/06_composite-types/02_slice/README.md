# 切片（Slice）

## 概述

切片（Slice）是 Go 中最常用的数据结构，
它提供了一个对数组的动态、灵活视图。

可以理解为：

> 切片是一个轻量级的结构体
> 指向一段数组的底层存储空间

与数组不同：

* 数组长度固定
* 切片长度可变
* 切片是引用类型（多个切片可共享同一底层数组）

---

## 切片的结构组成

每个切片底层由三部分组成（称为三元组）

| 字段    | 含义                   |
|-------|----------------------|
| `ptr` | 指向底层数组的指针            |
| `len` | 当前切片的长度（可访问的元素数量）    |
| `cap` | 容量（从起始位置到底层数组末尾的元素数） |

```
底层数组： [0][1][2][3][4][5][6]
切片 s  ：     ↑------ len=3
                ↑------------- cap=5
```

---

## 切片的创建方式

### 基于数组

```go
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:4] // 包含索引 [1,2,3]
```

切片共享数组内存；修改 `s` 会影响 `arr`

---

### 直接声明（零值）

```go
var s []int
```

* 初始值为 `nil`
* `len(s) == 0`，`cap(s) == 0`

---

### 使用内置函数 `make`

make 内置函数用来创建并初始化 slice、map、chan 这三种引用类型，
对于切片（slice），make 会 分配底层数组，并返回一个切片对象，

语法：`make([]Type, len, cap)`：

- len：切片的长度（初始化后能直接用下标访问的元素个数）
- cap：切片的容量（底层数组大小）

规则：必须满足 0 <= len <= cap

- 只指定 len 时 len = cap
- 如果 len > cap，会直接编译报错
- 如果 len == cap，切片刚好占满底层数组
- 如果 len < cap，切片“预留”了一些空间，方便后续 append
- 省略 cap 时，cap = len
- len=0 但 cap>0 时，切片为空，但有预留容量，只有在 0 <= index < len(slice) 时，下标赋值才合法

```go
s := make([]int, 3, 5)
```

* 创建长度为 3、容量为 5 的切片
* 底层自动分配数组
* 常用于预分配内存的场景

---

### 通过字面量初始化

```go
s := []string{"Go", "Rust", "C"}
```

* 同时创建切片与底层数组
* 最常见的写法

---

## 切片的核心特性

| 特性        | 说明                        |
|-----------|---------------------------|
| 引用类型      | 多个切片可指向同一底层数组             |
| 长度可变      | 可通过 `append` 动态增加         |
| 共享内存      | 子切片与原切片共享数据               |
| 自动扩容      | 超出容量时会创建新的底层数组            |
| 零值为 `nil` | 可安全使用（如 `append(nil, x)`） |

---

## 切片的长度与容量

| 函数       | 含义   |
|----------|------|
| `len(s)` | 当前长度 |
| `cap(s)` | 当前容量 |

扩容规则（大致）：

* 若 `len < cap`，直接扩展
* 若超出容量，则创建新的底层数组
* 扩容通常按 **2 倍策略** 增长（但不是固定）

---

## 切片的切片（Sub-slice）

通过下标范围 `[low:high]` 从现有切片中创建新切片

```
s2 := s1[1:4]
```

* 新切片共享底层数组
* 修改一个切片可能影响另一个
* `cap(s2)` = `cap(s1) - low`

---

## 切片的零值与 nil 切片

| 切片类型         | `len` | `cap` | `nil` 判定 | 可用性          |
|--------------|-------|-------|----------|--------------|
| 未初始化         | 0     | 0     | true     | 可安全 `append` |
| 空切片（`[]T{}`） | 0     | 0     | false    | 等价可用         |
| 非空切片         | >0    | ≥len  | false    | 正常使用         |

> `nil` 切片与空切片行为相似，但在底层内存不同

---

## 常用内置函数

| 函数                    | 功能   | 说明       |
|-----------------------|------|----------|
| `append(s, x...)`     | 追加元素 | 若超容量则扩容  |
| `copy(dst, src)`      | 复制内容 | 返回复制的元素数 |
| `len(s)`              | 获取长度 | 当前元素数量   |
| `cap(s)`              | 获取容量 | 最大容量     |
| `make([]T, len, cap)` | 创建切片 | 初始化指定容量  |

`append()` 可链式调用：

```
s = append(s, 1, 2, 3)
```

---

## 切片的扩容机制

切片扩容时：

* 若容量不足，Go 自动分配更大的底层数组
* 旧元素复制到新数组
* 原切片与新切片不再共享内存

**扩容策略（Go 实现层面概念化）：**

* 小容量（<1024）：每次约 2 倍
* 大容量：增长幅度逐渐减小
* 扩容由运行时自动完成，无需手动分配

---

## 切片的拷贝语义

| 行为        | 结果                 |
|-----------|--------------------|
| `s2 = s1` | `s2` 与 `s1` 共享底层数组 |
| 修改元素      | 两者同时受影响            |
| `copy()`  | 深拷贝内容，底层数组独立       |

> 赋值只是复制切片头（ptr, len, cap），不是复制数据。

---

## 比较与遍历

| 操作          | 说明               |
|-------------|------------------|
| `==` / `!=` | 仅可与 `nil` 比较     |
| 遍历          | 可使用 `for range`  |
| `range` 行为  | 遍历时复制切片头，不复制底层数组 |

若需比较内容，可使用：

* `reflect.DeepEqual(s1, s2)`
* 或循环逐元素比较

---

## 数组的对比

| 特征   | 数组（Array） | 切片（Slice）       |
|------|-----------|-----------------|
| 长度   | 固定        | 动态可变            |
| 类型定义 | `[N]T`    | `[]T`           |
| 内存分配 | 栈上（小）或堆上  | 自动管理            |
| 值/引用 | 值类型       | 引用类型            |
| 拷贝   | 拷贝整个数组    | 拷贝引用头           |
| 可扩展性 | 否         | 可通过 `append` 扩容 |
| 使用频率 | 较低        | 极高（Go 集合核心）     |

---

## 性能与内存特性

| 方面     | 特性                      |
|--------|-------------------------|
| 内存连续   | 提高缓存局部性（cache locality） |
| 扩容开销   | 新分配与复制，适度预分配可优化         |
| 零拷贝子切片 | 避免额外内存分配，但需小心共享风险       |
| GC 影响  | 共享底层数组可能导致“内存悬挂”保留      |

**优化建议：**

* 频繁扩容：提前 `make`
* 临时子切片：复制后再使用
* 大切片处理完后置 `nil`，帮助 GC

---

## 小结

| 项目     | 内容                             |
|--------|--------------------------------|
| 类型定义   | `[]T`                          |
| 底层结构   | 指针 + 长度 + 容量                   |
| 值/引用语义 | 引用类型，共享底层数组                    |
| 创建方式   | 字面量、切片表达式、`make`               |
| 核心函数   | `append`, `copy`, `len`, `cap` |
| 特性     | 动态扩容、共享内存、自动管理                 |
| 与数组区别  | 可变长度、轻量、常用                     |
| 应用范围   | 集合、缓存、动态序列                     |

> 切片是 Go 的动态数组实现
> 兼具性能与灵活性
> 是 Go 语言数据结构的核心抽象

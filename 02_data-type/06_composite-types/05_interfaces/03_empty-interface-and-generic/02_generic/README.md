# Go 泛型（Generics）

## 引入背景

* Go 在 1.18 版本正式引入泛型
* 目的：解决空接口（`interface{}`）过于动态、缺乏类型安全的问题
* 在 Go 1.17 及以前，想写通用算法（如 `Max`, `Sum`, `Map`）时只能用 `interface{}`，这带来了：
    * 无类型检查
    * 性能损耗（装箱 / 解箱）
    * 需要类型断言或反射
    * 代码可读性差
      泛型的出现，使这些问题得到根本解决

---

## 核心思想

> 泛型让函数、结构体、方法能够在编译时对类型参数化（type parameterization）

通俗理解：

> 可以把类型当作参数来写函数或结构体

编译器在编译期会根据传入的类型自动生成对应版本的函数（或类型），
因此既能保持类型安全，又能做到代码复用。

## 对比空接口

| 对比维度      | 空接口 `interface{}` | 泛型 `[T any]`          |
|-----------|-------------------|-----------------------|
| **类型检查**  | 运行时（无静态检查）        | 编译时（静态类型安全）           |
| **性能**    | 存在装箱 / 解箱开销       | 与普通类型一致（无额外开销）        |
| **灵活性**   | 高，但容易出错           | 高，且安全                 |
| **操作方式**  | 需类型断言或反射          | 可直接使用类型运算（如 +, >, ==） |
| **代码复用**  | 差，需要重复实现          | 强，一套逻辑适配多种类型          |
| **编译器行为** | 单一函数              | 为每种具体类型生成专用版本         |
| **使用场景**  | 动态数据（JSON、日志、配置）  | 静态算法（集合操作、数值计算、通用库）   |

## Go 泛型的主要使用场景

### 函数参数与返回值

* 在函数层面实现类型泛化
* 典型用途：`Max`, `Min`, `Sum`, `Map`, `Filter` 等通用算法
* 可同时声明多个类型参数 `[T, R any]`
* 可结合约束（`any`, `comparable`, 自定义接口）保证类型安全
* 也可以声明不定参数泛型

### 结构体定义

* 定义泛型数据结构，如：`Stack[T]`, `Queue[T]`, `Map[K,V]`, `Tree[T]`
* 通过结构体的类型参数实现对不同数据类型的复用
* 常用于实现容器类与集合类

### 接口约束

* 使用接口定义类型约束（constraint）
* 控制可用的运算或行为，例如：
    * `Number`（允许加减乘除）
    * `fmt.Stringer`（要求实现 `String()` 方法）
* 提供“类型能力”限定，使泛型既通用又安全

### 并发与通道

* 在通道或并发工具中使用泛型：
    * `chan T`、`WorkerPool[T]`、`FanIn[T]` 等
    * 构建类型安全的并发管道，不再依赖 `interface{}`

### 常见替代空接口的场景

* 通用集合算法（`Map`, `Reduce`, `Filter`）
* 数值运算函数（`Sum`, `Max`, `Average`）
* 通用容器（`Set`, `List`, `Heap`）
* 工具函数（`Keys`, `Values`, `Clone` 等）

## 约束（Constraint）

在泛型声明中，类型参数必须有一个约束`func FuncName[T constraint](param T) { ... }`。 约束定义了：

- 泛型类型参数 T 可以是哪些类型，
- 并且在函数体内可以使用哪些操作（例如比较、运算等）。

### 内置约束

| 约束名          | 含义              | 用途                 |
|--------------|-----------------|--------------------|
| `any`        | 任意类型（无限制）       | 最常用；默认通用           |
| `comparable` | 必须能使用 `==`、`!=` | 常用于比较、集合、map 的 key |

[T any]：可传入任意类型；
[T comparable]：只能传入可比较类型（如 int、string、指针等）

### 自定义约束（interface）

可以使用 interface 来编写自定义约束：

```go
type Number interface {
int | int64 | float64
}
```

- | 表示类型并集，只有在这个集合里的类型才允许作为类型实参
- 可以实现类型受限的通用算法（如加减乘除）

### 底层类型约束（~）

~ 表示底层类型为某种类型，允许自定义别名类型也满足约束

```go
type MyInt int

type Integer interface {
~int | ~int64
}
```

MyInt 的底层类型是 int，所以符合 ~int 的约束

### 组合约束

可以通过接口嵌套组合多个约束：

```go
type Ordered interface {
comparable
~int | ~float64 | ~string
}
```

> 类型既要可比较，又必须是这些底层类型之一

## 编译期行为

* 编译器在编译阶段，根据不同的类型参数生成专用代码
* 运行时不存在动态类型转换
* 没有反射、没有接口装箱
* 性能几乎与普通函数相同

## 泛型优势

* **减少重复代码**（尤其是算法、容器、工具类函数）
* **提升类型安全**（编译期发现类型错误）
* **提升性能**（避免 interface 运行时开销）
* **统一语义**（通过约束表达“类型能力”）

---

## 与空接口的关系

* 泛型不是空接口的替代品，而是**静态时代的升级版**
* 空接口解决“能接受任意类型”的问题，但类型检查滞后到运行时
* 泛型在编译期就完成类型推断与安全检查
* 二者关系可以这样理解：
    * 空接口：动态多态（运行时决定）
    * 泛型：静态多态（编译期展开）

## 补充

### 底层类型约束（~）和普通类型对比

int | float64 | string 和 ~int | ~float64 | ~string 对比

| 写法    | 含义       | 是否允许别名类型 | 示例                |     |                                 |
|-------|----------|----------|-------------------|-----|---------------------------------|
| `int  | float64  | string`  | **精确匹配类型**，只能是这三种 | 不允许 | 只能传入 `int`, `float64`, `string` |
| `~int | ~float64 | ~string` | **底层类型匹配**，允许别名类型 | 允许  | 可以传入自定义类型，如 `type MyInt int`    |

# 类型定义与类型别名（Type Definition & Type Alias）

## 概述

Go 是**强类型语言（strongly typed language）**，
它允许开发者在已有类型基础上：

* 定义新的类型（type definition）
* 或创建已有类型的别名（type alias）

这两种机制看似相似，却在类型系统、方法绑定、赋值兼容性上有根本区别。


> 定义新类型是创建新概念，创建别名是换个名字而已。

---

## 基础语法

两种语法形式：

```
// 类型定义（新类型）
type NewType BaseType

// 类型别名（别名）
type AliasType = BaseType
```

区别在于：

* `=` 存在 -> 只是别名；
* `=` 不存在 -> 定义了一个全新的类型。

---

## 类型定义（Type Definition）

### 语法

```
type MyInt int
type UserID string
```

### 含义

* 创建一个新类型
* 拥有相同的底层类型
* 但在类型系统中是完全独立的

> `MyInt` ≠ `int`
> `UserID` ≠ `string`

---

### 特性与影响

| 特性        | 说明                        |
|-----------|---------------------------|
| 类型独立      | 不能直接与原类型互换                |
| 赋值需显式转换   | `var a MyInt = MyInt(10)` |
| 方法定义独立    | 可为新类型定义方法                 |
| 零值与底层类型一致 | 但类型不同                     |

### 示例逻辑

```
type Celsius float64
type Fahrenheit float64
```

虽然二者底层都是 `float64`，但 Go 会严格区分，防止逻辑混淆（单位安全）

---

## 类型别名（Type Alias）

Go 1.9 引入的语法，用于给现有类型取一个新名字，但不产生新类型。

### 语法

```
type MyString = string
```

### 含义

* 不是新类型
* 只是原类型的**别名**
* 两者在编译期完全等价
* 可互相赋值，无需转换

> `MyString` == `string`（完全相同类型）

---

### 使用场景

| 场景   | 示例                                   | 说明          |
|------|--------------------------------------|-------------|
| 向后兼容 | `type Rune = int32`                  | Go 标准库中常见模式 |
| 简化名称 | `type JSON = map[string]interface{}` | 缩短复杂类型表达式   |
| 迁移过渡 | 重命名结构时保持旧代码可编译                       |             |

---

## 类型定义 vs 类型别名

| 项目     | 类型定义（`type T Base`） | 类型别名（`type T = Base`） |
|--------|---------------------|-----------------------|
| 是否新类型  | 是                   | 否                     |
| 与原类型关系 | 独立                  | 完全相同                  |
| 赋值兼容   | 需显式转换               | 可直接赋值                 |
| 方法定义   | 可独立定义方法             | 与原类型共享方法              |
| 零值     | 与底层类型相同             | 相同                    |
| 底层类型   | 相同                  | 相同                    |
| 常见用途   | 自定义语义、类型安全          | 简化命名、兼容旧代码            |

> 没有 `=` -> 新类型（独立概念）
> 有 `=` -> 别名（同一种类型）

---

## 类型定义的实际意义

类型定义最常用于：

* **语义区分**：让逻辑层更清晰
* **约束误用**：避免底层类型混淆
* **方法扩展**：为基本类型添加方法
* **接口实现**：通过方法绑定实现接口

### 语义化命名示例

```
type Meter float64
type Kilogram float64
```

即使都为 `float64`，也防止误传参数：

```
func Move(distance Meter, mass Kilogram)
```

---

## 方法与新类型（Method Binding）

类型定义的独特优势： 可为其绑定方法

```
type MyInt int

func (m MyInt) Double() MyInt {
return m * 2
}
```

底层类型不能直接添加方法，只能通过类型定义间接扩展。

这也是 Go 中包装内置类型的常用技巧。

---

## 类型别名的使用边界

类型别名完全共享底层类型的方法与实现。

```
type Rune = int32
```

-> `Rune` 与 `int32` 完全等价，方法、接口、零值、底层表现一致

常用于：

* 重命名库中已有类型
* 保留旧接口不破坏向后兼容性

例如 Go 标准库：

```
type rune = int32
type byte = uint8
```

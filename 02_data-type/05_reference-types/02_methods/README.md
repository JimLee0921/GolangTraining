# 方法（Method）

## 概述

在 Go 中，方法（Method） 是一种带有接收者（receiver）的函数。
将函数与特定类型绑定，使类型不仅能存储数据，还能定义行为。


> 方法 = 函数 + 接收者（Receiver）
> 函数操作独立数据，方法操作类型实例。

---

## 方法的基本语法

```
func (receiver ReceiverType) MethodName(params...) returnType {
    // 方法体
}
```

* `receiver`：接收者变量名（惯例用简短小写字母，如 `Receiver`: `r`、`Person`: `p`、`User`: `u`）
* `ReceiverType`：接收者的类型
* 方法名：首字母大写为导出方法
* 参数与返回值与普通函数一致

---

## 值接收者 vs 指针接收者

| 类型        | 声明形式     | 行为          |
|-----------|----------|-------------|
| **值接收者**  | `(r T)`  | 操作副本，不影响原对象 |
| **指针接收者** | `(r *T)` | 操作原对象，可修改字段 |

**Go 会自动解引用 / 取地址**：

* 当需要 `*T` 时，编译器可自动从 `T` 取地址
* 当需要 `T` 时，也可自动从 `*T` 取值

因此可以灵活调用：

```
var u User
u.SetName("Tom")
(&u).SetName("Tom")
```

两种写法都合法

---

## 方法与函数区别

| 对比项    | 函数（Function）         | 方法（Method）                   |
|--------|----------------------|------------------------------|
| 是否绑定类型 | 否                    | 有接收者                         |
| 定义形式   | `func FuncName(...)` | `func (r T) MethodName(...)` |
| 调用方式   | `FuncName(x)`        | `x.MethodName()`             |
| 首参数    | 显式传入                 | 隐式传入（接收者）                    |
| 适用类型   | 任意                   | 必须是命名类型或指针                   |

---

## 法接收者类型限制

接收者必须是：

* 命名类型（named type）
* 或该类型的指针

不允许为：

* 内建类型（如 `int`, `string`）不能直接定义方法
* 但可通过定义别名再绑定方法：

  ```
  type MyInt int
  func (m MyInt) Double() int { return int(m * 2) }
  ```

---

## 值接收者（Value Receiver）

值接收者方法操作的是类型的副本

* 不修改原对象
* 可用于不可变操作
* 自动支持从值或指针变量调用
* 对于小结构体性能无问题

示意逻辑：

```
func (u User) Show() { fmt.Println(u.Name) }
```

即使 `u` 是指针，调用 `u.Show()` 也会自动解引用

---

## 指针接收者（Pointer Receiver）

指针接收者方法操作的是类型的原始对象

* 可修改字段
* 避免大结构体复制
* 自动支持从值变量调用
* 在实现接口时，更灵活

示意逻辑：

```
func (u *User) SetAge(age int) { u.Age = age }
```

修改会作用到原对象。

---

## 值接收者与指针接收者的选择原则

| 场景                   | 推荐接收者 |
|----------------------|-------|
| 结构体较小，方法只读           | 值接收者  |
| 结构体较大（复制代价高）         | 指针接收者 |
| 方法需要修改字段             | 指针接收者 |
| 方法要实现接口（且接口方法集使用指针）  | 指针接收者 |
| 基础类型（自定义 int、string） | 值接收者  |

实际项目中，大多数结构体方法都会选择指针接收者

---

## 方法集（Method Set）

> 在 interface 章节再做更详细示例

每个类型都有一个方法集（method set），
定义了该类型可调用的方法。

| 类型   | 方法集包含                     |
|------|---------------------------|
| `T`  | 所有接收者为 `(T)` 的方法          |
| `*T` | 所有接收者为 `(T)` 和 `(*T)` 的方法 |

**含义：**

* 指针类型拥有更多方法
* 因此结构体若要实现接口，通常使用指针接收者

---

## 方法集的影响（接口实现）

假设：

```
type Printer interface {
Print()
}

type Doc struct{}
func (d Doc) Print() {}
```

则：

* `Doc` 和 `*Doc` 都实现了 `Printer`；
* 但如果方法为 `(d *Doc) Print()`，则：

    * 只有 `*Doc` 实现了接口；
    * `Doc` 本身没有该方法集。

> 值方法可由指针和值调用
> 指针方法只能由指针调用

---

## 方法表达式与方法值

本质就是把方法绑定到函数上

| 特性     | 方法值（Method Value） | 方法表达式（Method Expression）   |
|--------|-------------------|----------------------------|
| 是否绑定实例 | 已绑定               | 未绑定                        |
| 函数签名   | 不含接收者             | 含接收者参数                     |
| 调用方式   | `f(args...)`      | `g(receiver, args...)`     |
| 生成形式   | `v.Method`        | `T.Method` 或 `(*T).Method` |
| 常见用途   | 延迟调用、回调函数         | 泛型/函数式编程中作为函数引用            |
| 本质     | 闭包（封装了接收者）        | 普通函数                       |

### 方法表达式（Method Expression）

```
T.MethodName
(*T).MethodName
```

用于直接引用方法（不依赖实例），可用于回调或函数变量。

示意：

```
f := (*User).SetName
f(&u, "Tom")
```

### 方法值（Method Value）

```
m := u.MethodName
m()
```

* 把方法“绑定”到实例
* 类似闭包
* 常用于接口或回调场景

### 实际用途

1. 延迟执行(defer)
2. 回调函数
3. 闭包捕获对象状态

---

## 方法的可见性与导出规则

与变量相同：

* 首字母大写 -> 导出（public）
* 首字母小写 -> 包内可见（private）

> 方法可被导出，但其接收者类型也必须是导出的，否则其他包仍无法使用。

---

## 方法与函数的等价关系（底层视角）

方法本质上是函数的语法糖：

```
func (u User) Greet() { fmt.Println(u.Name) }
```

等价于：

```
func Greet(u User) { fmt.Println(u.Name) }
```

只不过方法的第一个参数隐式成为接收者
Go 编译器在编译期会将方法转换为普通函数形式



---

## 方法绑定与组合（Embedding）

如果一个结构体嵌入另一个结构体，它会自动继承嵌入类型的方法。

示意逻辑：

```
type Base struct{}
func (b Base) Hello() {}

type User struct{ Base }

u := User{}
u.Hello() // 提升方法
```

机制：

> 嵌入字段的方法会提升到外层结构体的命名空间。这是 Go 中组合优于继承的体现

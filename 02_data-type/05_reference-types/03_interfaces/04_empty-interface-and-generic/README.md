## Go 空接口与泛型

## 空接口

早期的的 Go 为了泛用性使用空接口牺牲了类型安全和性能

1. **失去类型检查**（编译器无法知道传进来的是什么类型）
2. **需要类型断言**（`.(type)`），代码啰嗦
3. **性能差**（每次传入都要装箱成 `interface{}`，运行时解包）
4. **容易出错**（类型断言错误直接 panic）

## 泛型

泛型 (Generics) 是 Go 1.18 后出现的增强特性，解决 interface{} 的类型不安全和性能问题；
目标很明确：

- 替代空接口在泛型逻辑场景下的滥用
- 编译器会根据传入的类型，生成专门化的代码
- 提供强类型检查，编译期就确定类型，不再需要断言，也没有性能损失

## 底层行为对比

| 对比点  | 空接口 `interface{}` | 泛型 `[T any]` |
|------|-------------------|--------------|
| 类型检查 | 运行时               | 编译时          |
| 类型安全 | 弱                 | 强            |
| 需要断言 | 是                 | 否            |
| 性能   | 慢（装箱/反射）          | 快（直接类型）      |
| 代码生成 | 单一函数              | 编译期生成多份函数    |
| 适合场景 | 动态、不确定类型（JSON、日志） | 静态、类型确定的算法   |
| 运算支持 | （要断言）             | （通过约束）       |
| 代表机制 | 运行时多态             | 编译期多态        |

## 内存模型

```
空接口传参：
 ┌────────────┐
 │  interface │
 │  _type → int
 │  data  → &value(123)
 └────────────┘
   ↓
 PrintAny(v interface{})

泛型传参：
 ┌──────────────┐
 │  int value   │   ← 直接传入编译期确定类型
 └──────────────┘
   ↓
 PrintGeneric 

```

## 总结

| 概念            | 本质                                 |
|---------------|------------------------------------|
| `interface{}` | 是一种具体类型，表示“任意值”                    |
| 泛型            | 是一种编译期机制，生成适用于不同类型的函数              |
| `any`         | 是语法糖：`type any = interface{}`      |
| `[T any]`     | 表示类型参数 T 被 “any” 约束，即可为任意类型        |
| 关系            | 泛型在语义上扩展了空接口的能力，是**静态类型时代的空接口升级版** |

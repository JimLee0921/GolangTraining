## 空接口（`interface{}`）

空接口：`interface{}` 就是不包含任何方法的接口，因为接口的本质就是类型必须实现接口中的所有方法，
而空接口没有方法，所以所有类型都自动实现了它，也就是实现了多态，
在 Go 中，空接口可以表示任意类型，可以接受任意类型的值

## 使用场景

1. 任意类型的值（作为函数参数）
2. 任意类型的集合（切片等）
3. 从空接口取值（类型断言）
    - Go 1.18 并且官方给空接口起了一个新别名：type any = interface{}
    - any 和 interface{} 是等价的，只是语义更直观：表示任意类型

## 工作原理

当把一个值赋给 `interface{}` 时，Go 会自动做两件事：

1. 存储**类型信息**（type descriptor）
2. 存储**实际数据**（data pointer）

可以把空接口理解为一种内部结构（简化表示）：

```
type eface struct {
_type *rtype         // 指向类型信息
data  unsafe.Pointer // 指向实际值
}
```

当调用：`PrintAnything(123)`，编译器会把 `123` 封装成一个这样的结构：
```
eface {
    _type = *int
    data  = &123
}
```

所以 `PrintAnything` 函数拿到的是一个类型+数据的组合，而不是裸值

这种行为称为装箱 (boxing)，也就是把具体类型值装进 interface 容器中

## 类型断言

如果想从空接口里取出原本的值，必须做类型断言

- 如果断言错误会 panic
- 可以使用安全写法`s, ok := v.(string)`，使用 ok 进行判断是否断言成功
- 也可以配合 `switch` 实现动态类型分支

## 常见用途

| 用途             | 示例                                        | 说明               |
|----------------|-------------------------------------------|------------------|
| 通用函数参数         | `func Print(v interface{})`               | 任意类型都能传          |
| 存储混合数据         | `[]interface{}{1, "hi", true}`            | 切片、map 中可混合多类型   |
| JSON 编码/解码     | `var data map[string]interface{}`         | 结构不确定的 JSON 数据   |
| context / 日志系统 | `context.WithValue(ctx, "key", anyValue)` | 存储任意类型值          |
| 早期替代泛型         | `func Add(a, b interface{})`              | 用于通用算法（现在建议改用泛型） |

## 缺点

空接口是 Go 的万能类型容器，可以装下任何值，但需要自己负责类型安全。它是 Go 动态多态的基础，而泛型则是后来出现的编译期静态多态方案，

| 问题     | 说明                           |
|--------|------------------------------|
| 失去类型安全 | 编译器无法检查类型，容易运行时崩溃            |
| 操作繁琐   | 需要类型断言或反射才能用                 |
| 性能下降   | 发生“装箱/解箱”过程                  |
| 难以阅读   | 函数参数都是 `interface{}`，不清楚期望类型 |

这些痛点就是 Go 后来引入泛型的直接原因


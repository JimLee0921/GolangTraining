# 指针（Pointer）

## 概述

指针（Pointer）是 Go 中用于引用内存地址的机制。
与 C/C++ 不同，Go 的指针安全、受限、无算术操作。


> 指针存储的是值在内存中的地址，通过它可以间接读取或修改该值。

---

## 为什么需要指针

Go 的所有变量在默认情况下都是 值语义（value semantics），
即赋值或传参时会产生副本。

常量 (const) 不能取地址，因为常量在编译时就已经确定，
它们不是存储在一个变量里，而是 直接内嵌在代码里的值。

指针的作用是：

* 在函数或方法中修改原值
* 避免大对象的复制开销
* 实现共享访问（多个变量指向同一内存）

---

## 基本概念

| 名称              | 含义             |
|-----------------|----------------|
| **指针（Pointer）** | 存储另一个变量的地址     |
| **取地址符 `&`**    | 获取变量的内存地址      |
| **解引用符 `*`**    | 访问指针指向的实际值     |
| **零值**          | `nil`（未指向任何地址） |

### 取地址符（`&`）

`&` 是取地址运算符（address-of operator），用来获取变量在内存中的地址。

```
x := 10
p := &x // p 是 *int 类型，存储 x 的地址
fmt.Println(p)  // 打印地址，例如：0xc0000140a8
fmt.Println(*p) // 10 （解引用，访问 x 的值）
```

* `x` 的类型是 `int`
* `p` 的类型是 `*int`
* `p` 存的是 x 的地址

### 取地址符的使用场景：

1. 创建指针

   ```
   p := &x
   ```

2. 传递变量地址给函数

   ```
   func addOne(p *int) { *p++ }
   x := 10
   addOne(&x)
   fmt.Println(x) // 11 
   ```

3. 结构体指针初始化

   ```
   u := &User{Name: "Tom"} // u 是 *User 类型
   ```

### 解引用符（`*`）

`*` 是解引用运算符（dereference operator），用来 访问或修改指针指向的值。

```
x := 10
p := &x
fmt.Println(*p) // 10 解引用，访问 x 的值
*p = 20        // 修改指针指向的值
fmt.Println(x) // 20 x 也被修改
```

### 解引用符的使用场景：

1. 读取指针指向的值

   ```
   fmt.Println(*p)
   ```

2. 修改指针指向的值

   ```
   *p = *p + 1
   ```

3. 结构体字段访问（自动解引用）

   ```
   type User struct { Name string }
   u := &User{Name: "Tom"}

   fmt.Println(u.Name)  // 自动解引用，等价于 (*u).Name
   u.Name = "Jerry"     // 等价于 (*u).Name = "Jerry"
   ```

---

## 指针的特性

| 特性          | 说明                       |
|-------------|--------------------------|
| 类型安全        | 指针类型与目标类型必须匹配            |
| 无指针算术       | 不允许 `p++` 或偏移操作          |
| 自动解引用（部分场景） | 结构体方法调用时可省略 `(*p).Field` |
| 无需手动释放      | 由 GC 自动管理内存              |

---

## 指针类型定义与声明

* 每种类型 `T` 都有对应的指针类型 `*T`
* 声明形式：

  ```
  var p *T
  ```
* 取地址：`p = &v`
* 解引用：`x = *p`

**零值行为：**

* `nil` 表示未指向任何内存
* 对 `nil` 解引用会 panic

---

## 指针常见用途

### 函数参数修改原值

函数默认传值，使用指针可修改原变量

### 减少内存复制

传递大结构体时，使用指针避免开销

### 实现共享状态

多个变量可指向同一内存，实现引用语义

### 方法接收者

在结构体方法中使用指针接收者可修改字段

---

## 指针与值类型的关系

| 类型                 | 是否值语义     | 是否可取地址 |
|--------------------|-----------|--------|
| 基本类型（int, float 等） | 是         | 是      |
| 数组（array）          | 是         | 是      |
| 切片（slice）          | 是（内部已含引用） | 是      |
| map                | 是（引用类型）   | 是      |
| struct             | 是         | 是      |
| interface          | 否（封装值指针）  | 是      |

**要点：**

* 只有值类型才需要通过指针共享
* 引用类型（slice、map、chan）本身已带有内部指针

---

## 结构体与指针的结合

> 更多见 composite-types 中的 struct 章节

结构体是值类型，通过指针可实现共享与修改字段。

示意：

```
u := User{Name: "Tom"}
p := &u
p.Name = "Jerry" // 修改原结构体
```

Go 编译器允许自动解引用：

```
(*p).Name == p.Name
```

---

## 指针的比较与零值

| 比较操作       | 含义         |
|------------|------------|
| `p == nil` | 判断是否为空指针   |
| `p == q`   | 判断是否指向同一地址 |

`nil` 是所有指针类型的零值，未初始化的指针即为 `nil`，不可解引用。

---

## 指针与函数传参语义

| 传参方式 | 行为     |
|------|--------|
| 值传递  | 复制参数值  |
| 指针传递 | 共享同一内存 |

示意：

```
func increment(x *int) {
    *x++
}
```

`increment(&a)` -> 修改 `a` 原值

> 所有函数参数在语义上都是值传递，只是传的值有时是指针。

---

## 指针与 new / make

| 函数              | 用途                        | 返回值      |
|-----------------|---------------------------|----------|
| `new(T)`        | 为类型 `T` 分配零值内存            | `*T`（指针） |
| `make(T, args)` | 初始化内建引用类型（slice/map/chan） | `T`（非指针） |

* `new` -> 任意类型，返回指针
* `make` -> 仅限内建引用类型

---

## 指针与垃圾回收（GC）

* Go 自动管理内存
* 无需手动 `free`
* 只要没有可达引用，内存会自动释放
* 不存在悬垂指针（dangling pointer）风险

> 指针安全性由编译器与 GC 保证

---

## 指针与接口的关系

* 接口可保存值或指针类型
* 实现接口时，取决于方法接收者

    * 若接口方法集要求指针接收者 -> 必须传指针
    * 若方法为值接收者 -> 值与指针都可实现

> 在 interface 章节讲解

---

## 逃逸分析（escape analysis）

Go 编译器会决定变量是在栈上还是堆上分配：

* 若指针被函数外部引用 -> 堆分配
* 否则 -> 栈分配

> 指针逃逸是 Go 性能调优的重要概念：它不会影响功能，但可能影响内存管理效率。



# 通道（Channel）

"Do not communicate by sharing memory; share memory by communicating."
—— 不要通过共享内存来通信，而要通过通信来共享内存。

## 概述

Channel（通道）是 Go 中用于 Goroutine 之间通信与同步的核心机制。
channel 是一种特殊的数据类型，让多个 goroutine 能够安全的传递数据，而无需显式加锁。

可以把理解为一条管道：一端塞东西（发送），另一端取东西（接收）。
是一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的，
在传统并发编程里，多个线程访问同一个共享变量容易出现资源竞争（race condition），
Go 提供了 channel，让 goroutine 之间 不用共享内存，而是 通过消息传递 来协作，替代手动加锁的一种更自然的并发工具。

> 类似于 python 中的 queue 队列
---

## Channel 的定义与创建

### 创建语法

```
ch := make(chan T)
```

| 语法                | 含义              |
|-------------------|-----------------|
| `chan T`          | 通道类型，元素类型为 `T`  |
| `make(chan T)`    | 创建一个无缓冲通道       |
| `make(chan T, N)` | 创建一个容量为 N 的缓冲通道 |

注意：

* 通道是引用类型
* 零值为 `nil`（未初始化）
* 对 `nil` 通道的发送或接收都会永久阻塞

### 基本定义

```text
var intChan chan int // 声明一个传输 int 的 channel，
var strChan chan string // 声明一个传输 string 的 channel
```

### 创建初始化

- make 会返回一个已初始化好的 channel，会分配底层数据结构，让 channel 可以正常收发
- make(chan T)：无缓冲（发送和接收必须同步配对），也就是发送与接收必须同时进行，否则会导致阻塞
- make(chan T, n)：有缓冲（最多能存放 n 个元素，满了才阻塞发送）

### 类型定义

在函数参数或变量中，可以限制 channel 的方向

```
var sendOnly chan<- int // 只能发送 int
var recvOnly <-chan int // 只能接收 int
```

- `chan<- T`：只发送通道，单向通道，只能用来发送（<- 放在 chan 右侧），只能执行 ch <- v
- `<-chan T`：只接收通道，单向通道，只能用来接收（<- 放在 chan 左侧），只能执行 v := <-ch
- 普通 chan T 是双向的，可以传给只写或只读，但反过来不行

---

### 核心特征

1. channel 有类型且严格区分
    - chan int -> 只能传 int
    - chan string -> 只能传 string
    - chan int 和 chan string 是完全不同的类型。
    - chan int 和 chan<- int / <-chan int 也不同

   > 所以 channel 就像有类型的安全队列

2. 同步 / 异步行为
    - 无缓冲 channel：发送和接收必须同步配对，像握手
    - 有缓冲 channel：可以存一定数量的数据，发送不会立刻阻塞，允许发送方和接收方的速度不完全一致

3. 双向或单向
    - 默认：chan T -> 双向（既能收又能发）
    - 限制：chan<- T（只发）、<-chan T（只收）

4. 并发安全
    - Go 的 channel 是线程安全的
    - 多个 goroutine 可以同时向同一个 channel 发数据，或者取数据，不需要额外加锁

注意事项：

- var 声明的 channel 默认值是 nil，而 nil channel 不能收发数据
- 如果对 nil channel 执行发送或接收操作，会永久阻塞（deadlock）
- 但是，读取 nil channel 本身是安全的（只要不去 <-ch 或 ch <- x 就没问题）

## 发送与接收操作

* 发送与接收操作都会阻塞，直到另一方准备好
* 这使得 Channel 同时具备通信与同步能力

### 语法规则

| 操作    | 语法            | 行为       |
|-------|---------------|----------|
| 发送    | `ch <- value` | 将值发送到通道中 |
| 接收    | `x := <-ch`   | 从通道接收一个值 |
| 丢弃接收值 | `<-ch`        | 接收但忽略结果  |

### 发送

发送(send)：`ch <- value`，把 value 发送到 channel ch

- 如果是 无缓冲 channel，发送会阻塞，直到有接收方准备好取走
- 如果是 有缓冲 channel，当缓冲区未满时，发送不会阻塞

### 接收

接收(receive)：`value := <-ch`，从 channel ch 接收一个值，并赋给 value，接收的次序是按照发送的次序，先进先出

- 管道如果没有数据（无缓冲通道还没有发送方或有缓冲通道但当前为空）：无缓冲 -> 阻塞，直到有人发送，有缓冲 -> 阻塞，直到缓冲里有数据
- 常用于安全接收： `v, ok := <-ch`
    - ok == true -> 接收到正常数据
    - ok == false -> channel 已关闭，且读到的是该类型的零值

### 关闭

关闭通道(close)：`close(ch)`，表示 不会再向 channel 发送数据

> 如果管道不往里存值或者取值的时候一定记得关闭管道

- 已经在 channel 里的数据仍可继续接收
- 再向已关闭的 channel 发送 -> panic
- 从已关闭的 channel 接收 -> 得到零值，并且 ok=false
- 多次关闭 -> panic
- 从未关闭的通道中 range -> 死锁

---

## 管道类型

管道分为有缓存管道和无缓冲管道

### 无缓冲通道（Unbuffered Channel）

无缓冲通道就是容量为 0 的 channel。
它的特点是：

- 发送和接收必须同时发生：发送方必须等待接收方并且接收方也必须等待发送方
- 否则双方会被阻塞，保证了内存可见性和顺序一致性
- 这是一种同步通信的机制（handshake 模式）
- 通道无人接收/无人发送会直接导致死锁

```
ch := make(chan int)
```

```
func main() {
    ch := make(chan int)
    ch <- 1 // 没有接收方，会永久阻塞
}
```

可以把无缓冲通道理解为一手交钱、一手交货的现场交易：

| 时间 | 发送方        | 接收方        |
|----|------------|------------|
| t₀ | 尝试发送 -> 等待 | 还未准备 -> 阻塞 |
| t₁ | 接收方准备好     | 数据交接       |
| t₂ | 双方继续执行     |            |

**用途：**

* 控制同步
* 实现任务完成信号
* 确保数据严格交替传递

---

### 有缓冲通道（Buffered Channel）

在 无缓冲通道 中，发送和接收必须同时发生。
而 有缓冲通道 提供了一块中间存储区，
允许发送方在没有立即接收方的情况下，先发再走。

```
ch := make(chan int, 3)
```

- int：通道内元素类型
- 3：缓冲区容量（最多存 3 个值）
- 可以理解为一个「队列」，先进先出（FIFO）

| 通道状态 | 发送方行为   | 接收方行为   |
|------|---------|---------|
| 缓冲未满 | 可继续发送   | 若无数据则阻塞 |
| 缓冲已满 | 阻塞等待接收方 | 可继续接收   |
| 通道为空 | 可发送     | 阻塞等待发送方 |

**用途：**

* 异步任务队列
* 提升吞吐性能
* 减少等待延迟

---

## 循环取值

接收 channel 数据既可以用单次 <-ch，也可以用 for range ch

它们的使用场景有点不同

### 单次接收

语法：`v, ok := <-ch`

- 适合场景：只需要接收 一次或有限几次
- 如果 channel 已经关闭并且没有数据了，返回的是零值
- 一般搭配 value, ok := <-ch 来判断是否关闭

循环取值使用 `ok=false` 进行判断

```
for {
    v, ok := <-ch
    if !ok {
        break // 通道已关闭，跳出循环
    }
    fmt.Println(v)
}
```

特点：

- 使用显式 ok 判断
- ok == true -> 成功读取
- ok == false -> 通道关闭且无更多数据
- 自己控制退出条件

适用场景：

- 需要手动处理关闭逻辑
- 需要在关闭时执行额外操作（例如：清理资源、打印日志、发信号）
- 或者通道在循环体内可能被多次切换、替换

运行机制：

- 每次 <-ch 都会尝试从通道取数据
- 若通道已关闭并且数据已读完，则返回零值和 ok=false
- 不会 panic ，退出循环后即可安全关闭下一个通道

### 循环接收

for v := range ch（必须关闭 channel否则会永久堵塞）

- 适合场景：需要把 channel 里的所有数据都读完
- 会一直接收，直到 channel 被关闭并且数据读完为止
- 常见在 生产者关闭 channel，消费者消费所有数据 的模式里

```
for v := range ch {
    fmt.Println(v)
}
```

特点：

- 由 Go 内部自动完成 ok 检查
- 当通道被关闭并且数据读完时，自动退出循环
- 更简洁、惯用（idiomatic Go style）

适用场景：

- 单一通道的遍历
- 明确知道通道会被关闭
- 不需要特殊退出处理

底层逻辑等价于：

```
for {
    v, ok := <-ch
    if !ok {
        break
    }
    fmt.Println(v)
}
```

| 对比项         | `for { v, ok := <-ch }` | `for v := range ch` |
|-------------|-------------------------|---------------------|
| 是否自动检测关闭    | 否，需要手动判断                | 是，自动退出              |
| 是否能取到 ok 状态 | 可以直接取到                  | 不提供 ok，但隐含判断        |
| 适合复杂逻辑      | 可以自由控制退出条件              | 简洁但不灵活              |
| 写法简洁度       | 稍冗长                     | 简洁优雅                |
| 推荐场景        | 多通道、需特殊退出逻辑             | 单通道连续读取             |

## 单向通道（Directional Channel）

在默认情况下，通道是 双向的（bidirectional）：
`ch := make(chan int)`：这个通道既可以发送（ch <- x），也可以接收（x := <-ch）

但在某些函数中，只希望：

- 某个函数只负责发送数据
- 另一个函数只负责接收数据

这时候，为了避免误操作（例如错误地接收/发送），
就可以使用 单向通道类型 来限制通道的使用方向。

### 单向通道声明

为了约束使用方向，可声明单向通道：

| 方向  | 语法         | 说明        |
|-----|------------|-----------|
| 只发送 | `chan<- T` | 只能向通道发送数据 |
| 只接收 | `<-chan T` | 只能从通道接收数据 |
| 双向  | `chan T`   | 既能发送也能接收  |

常用于函数参数传递，防止误用：

```
func producer(out chan<- int) { ... }
func consumer(in <-chan int) { ... }
```

### 方向转换规则

Go 中单向通道和双向通道转换时只允许降级，
可以把一个双向通道传给单向通道参数（安全），
但不能把单向管道转换为双向。

| 方向转换                         | 是否允许 |
|------------------------------|------|
| `chan T`      ->  `chan<- T` | 允许   |
| `chan T`      ->  `<-chan T` | 允许   |
| `chan<- T`    ->  `chan T`   | 不允许  |
| `<-chan T`    ->  `chan T`   | 不允许  |

---

## 管道容量与长度

对于管道而言

| 函数        | 含义                |
|-----------|-------------------|
| `cap(ch)` | 通道缓冲区总容量（能存多少个元素） |
| `len(ch)` | 当前通道中已有多少个元素      |

### 有缓存管道

`ch := make(chan int, 3) // 容量为3的缓冲通道`

- cap(ch) 永远等于创建通道时指定的容量
- len(ch) 表示当前通道存了多少个元素
- 每次 ch <- x → len(ch) 加 1
- 每次 <-ch → len(ch) 减 1

### 无缓存管道

```
ch := make(chan int) // 无缓冲通道
fmt.Println(cap(ch)) // 0
fmt.Println(len(ch)) // 0
```

- 无缓冲通道的容量 cap = 0
- 永远不会积压数据：发送必须有接收方同时存在
- 所以 len() 永远是 0（因为不会存值）

### 注意事项

| 注意事项             | 说明                             |
|------------------|--------------------------------|
| 不要依赖 len 判断通道空不空 | 并发情况下 len 可能刚读完马上又被写入，结果不可靠    |
| 不要用 len 控制循环退出   | 通道关闭才是可靠信号（`for range` 或 `ok`） |
| len/cap 适合打印调试   | 用于观察缓冲变化、分析性能或限流               |
| cap 可作固定容量控制     | 确认通道的最大缓存空间                    |

## select 与多通道通信

> 简单介绍，在 select 章节详解

`select` 可同时监听多个通道操作：

```
select {
case v := <-ch1:
    fmt.Println(v)
case ch2 <- 42:
    fmt.Println("sent")
default:
    fmt.Println("no communication")
}
```

特性：

* 随机选择可执行的 case
* `default` 用于非阻塞
* 是多通道协作的基础

---

## 通道的零值与 nil 通道

| 通道状态      | 发送/接收行为         |
|-----------|-----------------|
| 未初始化（nil） | 永久阻塞            |
| 正常通道      | 正常通信            |
| 已关闭通道     | 接收返回零值，发送 panic |

---

## 同步语义（Memory Model）

Channel 除了通信外，还提供内存同步保证：

如果 Goroutine A 向通道发送值，而 Goroutine B 从该通道接收该值，
那么在发送操作之前对内存的所有写入，对 B 来说都是可见的。

即：

* Channel 自带 happens-before 顺序
* 不需要额外的锁或内存屏障
* 是 Go 并发安全的基础

---

## channel 和 CSP 模型

Go 的并发模型来源于 CSP（Communicating Sequential Processes）理论。
其核心思想：

> 进程之间不直接共享内存，而是通过消息传递通信。

Goroutine + Channel = CSP 实现

| 概念          | 对应        |
|-------------|-----------|
| Process（进程） | Goroutine |
| Channel（通信） | Channel   |
| Select（选择）  | Select 语句 |






# Mutex 解决资源竞争

多个 goroutine 同时访问同一个共享资源（变量、map、文件等），
如果没有任何顺序控制，就会出现数据错乱。

加锁的目的就是：让同一时刻只有一个 goroutine 能访问这块资源。

## 互斥锁

资源竞争 = 并发读写同一份可变数据且缺少同步，而锁的作用是同一时刻只允许一个 goroutine 修改（或 RWMutex 允许并发读、独占写）

Go 的锁是进程内同步原语：sync.Mutex、sync.RWMutex 的零值可用，在解锁时也可以使用 `defer` 关键字确保解锁成功

- sync.Mutex：普通互斥锁，任何访问都独占
- sync.RWMutex：读写锁，允许多个读者同时读，但写时独占，当存在「多读少写」的情况时，可以用 读写锁 来提升性能

互斥锁主要方法：

| 方法          | 所属锁             | 作用        | 是否阻塞其他读 | 是否阻塞其他写 |
|-------------|-----------------|-----------|---------|---------|
| `Lock()`    | Mutex / RWMutex | 加写锁（独占访问） | 是       | 是       |
| `Unlock()`  | Mutex / RWMutex | 释放写锁      | -       | -       |
| `RLock()`   | RWMutex         | 加读锁（共享访问） | 否       | 是       |
| `RUnlock()` | RWMutex         | 释放读锁      | -       | -       |

## 工作原理

当多个 goroutine 竞争访问同一段代码（临界区）时：

| goroutine                     | 状态               |
|-------------------------------|------------------|
| 第一个调用 `mu.Lock()` 的 goroutine | 获得锁，进入临界区        |
| 其他 goroutine                  | 阻塞在 `Lock()` 处等待 |
| 当前 goroutine 调用 `mu.Unlock()` | 释放锁，唤醒下一个等待者     |

> 保证同一时间最多只有一个 goroutine 在访问共享资源

## 安全解锁

使用 `defer` 关键字，即使函数中途出错也能保证最终解锁

```
mu.Lock()
defer mu.Unlock()
counter++
```

## 注意事项

| Lock/Unlock 原则  | 说明                         |
|-----------------|----------------------------|
| 一定要成对使用         | 每次 `Lock()` 后必须 `Unlock()` |
| 建议使用 `defer` 解锁 | 防止函数异常提前返回而忘记解锁            |
| 临界区应尽量短         | 锁住的范围越小，性能越好               |
| 不要重复上锁          | 同一个 goroutine 再次 Lock 会死锁  |
| 不要忘记 Unlock     | 否则其他 goroutine 永远阻塞        |


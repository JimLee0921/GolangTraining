在并发程序中，常常需要一种机制来：

| 需求         | 例子                      |
|------------|-------------------------|
| **等待任务完成** | 等所有 Goroutine 都处理完任务再退出 |
| **通知结束**   | 通知子 Goroutine 停止工作      |
| **协调阶段**   | 等待多个信号后再进行下一步操作         |

Go 提供了两大类方案来实现这种同步：

| 类型              | 示例                   | 机制            |
|-----------------|----------------------|---------------|
| **结构化同步（同步原语）** | `sync.WaitGroup`     | 等待协程完成        |
| **信号式同步（通信机制）** | `done chan struct{}` | 通过 Channel 通知 |

## `done channel` —— 信号式同步机制

用于处理多个通道之间的选择操作，尤其是在需要监听多个通道并在其中一个完成或发送信号后立即停止整个操作时非常有用

### 定义

`done` 通道是通过 Channel 实现的信号同步机制。
一般定义为：

```
done := make(chan struct{})
```

类型使用 `struct{}` 是因为不需要传输任何数据，仅作为信号。

### 工作原理

| 阶段   | 操作                | 说明         |
|------|-------------------|------------|
| 启动协程 | `go worker(done)` | 子协程监听通道    |
| 通知结束 | `close(done)`     | 向所有监听方广播信号 |
| 协程退出 | `<-done` 返回       | 收到关闭信号自动退出 |

特点：

* 适合广播式信号通知
* 所有协程监听同一个 `done` 通道
* 可在 `select` 中与其他通道同时监听

## 用途对比

| 对比项        | `sync.WaitGroup` | `done channel`     |
|------------|------------------|--------------------|
| 主要用途       | 等待所有协程完成         | 通知所有协程停止           |
| 是否可取消      | 不可               | 可取消                |
| 是否可广播      | 否（需循环 Wait）      | 是（close 一次，全员收到）   |
| 是否能 select | 否                | 可在 select 中监听      |
| 是否可重用      | 可（重置 Add）        | ️ 一次性（close 后不能复用） |
| 是否传输数据     | 否                | 可扩展（但通常不传）         |
| 常见场景       | Worker Pool 收尾   | Context-like 取消信号  |

## 选择时机

| 场景                    | 推荐机制                                |
|-----------------------|-------------------------------------|
| 需要等待所有协程完成任务          | `WaitGroup`                         |
| 需要向多个协程广播停止工作         | `done channel`                      |
| 想在 `select` 中响应取消或超时  | `done channel`                      |
| 短期并发任务批处理             | `WaitGroup`                         |
| 长期运行的 worker / server | `done channel`（或 `context.Context`） |
| 需要可取消的同步等待            | `context.Context`（done 的上层封装）       |

## 最佳实践

1. 通常使用 `close(done)` 而非发送值 -> 关闭通道能同时唤醒所有监听者
2. 通道类型用 `chan struct{}`-> 不占用额外内存
3. 命名统一为 `done`-> 语义清晰、社区约定俗成
4. 一次性使用 -> 关闭后不能再次发送
5. 与 `context.Context` 一致语义 -> Context 本质上也是基于 `done` 通道封装的

## Context 与 done

`context.Context` 内部其实就是使用 `done chan struct{}` 实现的取消机制：

```
type Context interface {
    Done() <-chan struct{}
    Err() error
    Deadline() (time.Time, bool)
}
```

> `context` 是高级封装版的 `done channel`，带有超时、值传递、错误等附加功能。
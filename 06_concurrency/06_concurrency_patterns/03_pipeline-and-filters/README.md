# 管道与过滤器模式（Pipeline and Filters Pattern）

## 定义（Definition）

`Pipeline and Filters Pattern` 是一种结构化架构模式。
将一个大的处理任务拆分成多个小的处理步骤，每个步骤都是一个独立的过滤器，它们串联起来形成一个管道。
每个过滤器只负责一个简单的任务，比如转换数据格式、过滤掉无用信息等。通过这种方式，可以使得复杂的处理任务更加可控、易于维护。

在 Go 语言中，可以使用管道和过滤器模式来处理一些数据处理任务，比如日志处理、图像处理等。
管道是一种可以实现并发处理的数据结构，它可以将数据从一个过滤器传递到另一个过滤器，并最终输出处理结果。
过滤器是实际进行数据处理的组件，它们可以被串联起来形成一个处理管道。


> 把一串逻辑拆成连续的独立阶段（filter），这些阶段用通道（pipe）相连。

## 组成部分（Components）

| 角色                | 说明                                     | go 中实现             |
|-------------------|----------------------------------------|--------------------|
| **Filter（过滤器）**   | 独立的处理单元（相当于一个阶段/函数），输入->处理->输出         | `goroutine` + 处理逻辑 |
| **Pipe（管道）**      | 连接过滤器的通道，负责传递数据                        | `chan T`           |
| **Pipeline（管道线）** | 整个处理流的组合（Filter + Pipe + Filter + ...） | 多个阶段组合的整体          |

Go 的 goroutine + channel 组合，
天然适合表达这种模式：

```
source -> filter1 -> filter2 -> filter3 -> sink
```

每个过滤器：

* 独立 goroutine
* 输入通道 `in <-chan T`
* 输出通道 `out chan<- U`
* 内部执行循环 + 关闭 out

## 核心特性

| 特性       | 描述                       |
|----------|--------------------------|
| **分阶段**  | 每个阶段（过滤器）独立执行，便于维护和复用    |
| **流式处理** | 数据连续流动，不必等所有数据生成完再处理     |
| **可组合性** | 可自由组合、重用不同过滤器            |
| **并发友好** | 每个过滤器可在单独的 goroutine 中运行 |
| **天然背压** | 通道（pipe）自动阻塞控制流速         |

## 适用场景

| 场景      | 示例                           |
|---------|------------------------------|
| 数据处理流水线 | 读取 -> 解析 -> 转换 -> 输出         |
| 流式计算    | 日志流 -> 聚合 -> 存储              |
| 文件/网络处理 | 下载 -> 解压 -> 解码 -> 保存         |
| ETL 系统  | Extract -> Transform -> Load |

## 优势与权衡

### 优势

* 结构清晰、职责单一
* 模块可复用
* 易于并行
* 流式节省内存
* 通道提供自动背压

### 劣势

* goroutine 太多时调度成本上升
* 调试困难（非线性调用栈）
* 错误处理需显式传播
* 延迟分析复杂

## 和其他模式的关系

| 模式                    | 关系                             |
|-----------------------|--------------------------------|
| **Producer–Consumer** | Pipeline 的最简形式（只有两级：生产者 + 消费者） |
| **Worker Pool**       | Pipeline 的横向扩展形式（同一过滤器的并发副本）   |
| **Fan-in / Fan-out**  | Pipeline 的结构变体，用于多路合并或分发       |



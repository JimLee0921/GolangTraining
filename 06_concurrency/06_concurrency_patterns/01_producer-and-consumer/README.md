# 生产者–消费者

生产者–消费者模式（Producer–Consumer Pattern） 是最经典的并发通信模型。
核心思想是：

- 生产者（Producer）负责生成任务
- 消费者（Consumer）负责处理任务
- 两者通过 Channel 实现解耦与同步

在 Go 中，这个模式天然契合 Go 的 CSP 并发模型（Communicating Sequential Processes）理念。


> 生产者只管放任务，消费者只管取任务，Channel 就是它们之间的安全通信桥梁。

---

## 模式结构与要素

### 模型组成

| 角色                | 说明                            |
|-------------------|-------------------------------|
| **Producer（生产者）** | 生成任务（数据、请求、事件）并发送到通道          |
| **Channel（通道）**   | 承载任务的队列，用于 goroutine 之间的通信与同步 |
| **Consumer（消费者）** | 从通道中接收任务并执行处理逻辑               |

### 模式目标

| 目标       | 说明                 |
|----------|--------------------|
| **解耦**   | 生产与消费的速率不同步也不冲突    |
| **并发**   | 多个消费者可以并行处理任务      |
| **缓冲**   | Channel 可作为任务队列缓冲区 |
| **稳定性**  | 防止任务丢失或协程阻塞        |
| **可扩展性** | 容易扩展为多生产者、多消费者模式   |

### 模式实现思路

1. 创建任务通道 `jobs := make(chan Job, N)`
2. 启动若干生产者协程负责发送任务
3. 启动若干消费者协程负责接收任务
4. 主协程等待所有任务完成后关闭通道

> Channel 负责同步 + 通信，避免显式锁操作。

### 通信方式与同步关系

| 通道类型  | 特点                | 应用场景       |
|-------|-------------------|------------|
| 无缓冲通道 | 同步通信，发送方阻塞直到接收方取走 | 任务速率相近     |
| 有缓冲通道 | 异步通信，可暂存任务        | 生产快、消费慢的场景 |

> Go 的无锁通信正是基于这种 Channel 的同步机制实现的。

### 逻辑示意流程

```
[Producer Goroutines]
       ↓   ↓   ↓
    ┌─────────────┐
    │   Channel    │
    │  (任务通道)  │
    └─────────────┘
       ↓   ↓   ↓
[Consumer Goroutines]
```

### 扩展模型

| 模型类型         | 描述          |
|--------------|-------------|
| 单生产者 -> 单消费者 | 最简单模型       |
| 单生产者 -> 多消费者 | 并行处理任务（常用）  |
| 多生产者 -> 单消费者 | 多源汇聚到一个消费者  |
| 多生产者 -> 多消费者 | 典型分布式任务队列结构 |

> 多生产者–多消费者就是 Go 的 Fan-in / Fan-out 模式的基础。

## Channel

* Channel 是通信管道
* Go 中的 Channel 天然线程安全
* 使用 Channel 代替共享内存，符合 Go 的哲学

> 不要通过共享内存来通信，而要通过通信来共享内存

### Channel 生命周期管理

| 操作    | 注意事项                   |
|-------|------------------------|
| 关闭通道  | 由生产者关闭（表示无新任务）         |
| 消费者退出 | 读取 `ok == false` 时退出循环 |
| 同步等待  | 使用 WaitGroup 等待所有任务完成  |

> 关闭通道是结束信号，不是销毁通道

---

### 错误与陷阱

| 问题                                         | 原因                 |
|--------------------------------------------|--------------------|
| 死锁（fatal error: all goroutines are asleep） | 未关闭通道或无消费者         |
| 阻塞                                         | 消费速度 < 生产速度，缓冲满    |
| 任务丢失                                       | 提前关闭通道或消费错误        |
| 数据竞争                                       | 未正确同步任务状态          |
| 资源泄漏                                       | 协程未退出（未监听 Done 信号） |



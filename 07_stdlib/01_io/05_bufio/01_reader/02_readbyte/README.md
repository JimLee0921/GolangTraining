## ReadByte 按字节读取

### 方法定义

```
func (b *Reader) ReadByte() (byte, error)
```

返回值：

- byte：读取到的单个字节
- error：错误对象，常见的是：
    - nil：正常读取
    - `io.EOF`：到达流末尾
    - 其他：底层读取出错

### 底层原理

ReadByte() 是 Read 的简化版，核心逻辑如下：

1. 优先使用缓冲区数据
    - 如果 `b.buf`（内部缓冲区）里还有数据，直接取一个字节返回
    - 取出后会将 `b.r`（读指针）往后移动一位

2. 缓冲区为空则重新填充
    - 如果缓冲区用完，就调用底层 `io.Reader` 读取一批数据（比如 4096 字节）放进缓冲区
    - 然后取出第一个字节。

3. 读到末尾返回 `io.EOF`
    - 若底层 `io.Reader` 也返回 0 字节，则 ReadByte 返回 (0, `io.EOF`)

### 使用场景

| 场景                  | 说明                          |
|---------------------|-----------------------------|
| **逐字节解析**           | 处理二进制协议、逐字节判断标志位等           |
| **自定义分隔符读取**        | 比如手动实现“读到 `,` 为止”           |
| **前瞻读取（Lookahead）** | 搭配 `UnreadByte()` 判断下一个字符类型 |

## UnReadByte

常和 ReadByte() 配合使用，是 回退（回滚）上一次读取的单个字节 的工具。

### 方法定义

```
func (b *Reader) UnreadByte() error
```

返回值：

- error：如果无法回退，返回错误（如连续多次回退、未读过字节等）；否则返回 nil

### 方法作用

用于撤销最近一次 ReadByte() 操作，使下次读取时能重新读到那个字节。

举例理解：

- 假设读到一个字节 'a'，但是发现接下来的逻辑还需要重新处理 'a'
- 那么调用 UnreadByte() 后，下次 ReadByte() 会再次读到 'a'

### 使用限制

| 限制                         | 说明                                  |
|----------------------------|-------------------------------------|
| **只能回退一次**                 | 连续调用两次会报错 `bufio: can't unread byte` |
| **必须在上次 `ReadByte()` 后调用** | 如果刚用 `ReadRune()` 或 `Read()`，也会报错   |

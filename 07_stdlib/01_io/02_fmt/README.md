# FMT

fmt 包是 Go 语言的格式化输入输出包（Format I/O 的缩写）。

## 简介

fmt 包实现了格式化 I/O，其功能类似于 C 语言的 `printf` 和 `scanf`。格式动词源自 C 语言，但更简单。

### 主要作用

- 把内容输出到屏幕（终端）或字符串中
- 把输入从键盘或文件中读取并解析出来
- 支持各种格式化控制（类似 C 语言的 `printf` / `scanf` 系列函数）

## 常用格式化动词

| 类别      | 动词     | 说明                         | 示例输出                      |
|---------|--------|----------------------------|---------------------------|
| **整数**  | `%d`   | 十进制                        | `42`                      |
|         | `%b`   | 二进制                        | `101010`                  |
|         | `%o`   | 八进制                        | `52`                      |
|         | `%x`   | 十六进制（小写）                   | `2a`                      |
|         | `%X`   | 十六进制（大写）                   | `2A`                      |
| **浮点**  | `%f`   | 小数形式，默认 6 位小数              | `3.141593`                |
|         | `%.2f` | 小数形式，保留 2 位                | `3.14`                    |
|         | `%e`   | 科学计数法（小写 e）                | `3.141593e+00`            |
|         | `%E`   | 科学计数法（大写 E）                | `3.141593E+00`            |
|         | `%g`   | 自动选择 `%f` 或 `%e`（更紧凑，小写 e） | `3.14159` / `1.23e+08`    |
|         | `%G`   | 自动选择 `%f` 或 `%E`（更紧凑，大写 E） | `3.14159` / `1.23E+08`    |
| **字符串** | `%s`   | 原样输出字符串                    | `hello`                   |
|         | `%q`   | 带双引号并转义                    | `"hello\nworld"`          |
|         | `%x`   | 字符串/字节切片转十六进制（小写）          | `68656c6c6f` (`Hello`)    |
| **布尔**  | `%t`   | 布尔值                        | `true` / `false`          |
| **通用**  | `%v`   | 默认格式输出值                    | `fmt.Printf("%v", user)`  |
|         | `%+v`  | 连同字段名打印结构体                 | `fmt.Printf("%+v", user)` |
|         | `%#v`  | 用 Go 语法格式打印                | `fmt.Printf("%#v", user)` |
|         | `%T`   | 打印变量类型                     | `fmt.Printf("%T", x)`     |

## `fmt` 打印函数

| 功能类型              | 输出目标                  | 常用函数                            | 说明                |
|-------------------|-----------------------|---------------------------------|-------------------|
| **标准输出（屏幕）**      | 标准输出（`os.Stdout`）     | `Print`, `Println`, `Printf`    | 最常用，直接打印到控制台      |
| **格式化为字符串**       | 返回字符串（不打印）            | `Sprint`, `Sprintln`, `Sprintf` | 拼接或格式化字符串后返回      |
| **输出到自定义 Writer** | 任意实现了 `io.Writer` 的对象 | `Fprint`, `Fprintln`, `Fprintf` | 比如写入文件、网络连接、内存缓冲等 |

### print 输出函数

| 函数名             | 功能                   | 是否自动换行          | 返回值       |
|-----------------|----------------------|-----------------|-----------|
| `fmt.Print()`   | 直接打印内容，不加空格、不换行的原始输出 | 不自动换行           | 打印的字节数、错误 |
| `fmt.Println()` | 打印并自动加空格和换行，最常用的普通输出 | 自动换行            | 打印的字节数、错误 |
| `fmt.Printf()`  | 按格式控制输出，格式化输出        | 不自动换行（除非加 `\n`） | 打印的字节数、错误 |

### sprint 生成字符串将函数

`fmt` 除了能“打印到屏幕”，还可以把格式化后的内容生成字符串

* `fmt.Printf()` -> 打印到屏幕。
* `fmt.Sprintf()` -> 返回字符串（不打印）。
* `fmt.Fprint()` -> 输出到文件或网络连接。
* `fmt.Sprint()` -> 普通拼接（不格式化）。
* `fmt.Sprintln()` -> 自动加空格与换行。
* `fmt.Sprintf()` -> 支持格式化控制符（最常用）

**常用函数总览**

| 函数名          | 功能         | 是否自动换行 | 是否支持格式符 |
|--------------|------------|--------|---------|
| `Sprint()`   | 把参数拼接成字符串  | 否      | 否       |
| `Sprintln()` | 拼接并加空格、换行  | 是      | 否       |
| `Sprintf()`  | 按格式控制输出字符串 | 否      | 是       |

> 常用于把所有参数拼接成一个字符串，不打印，返回给变量。常用于日志拼接、字符串构造

### fprint

`Print` 系列都默认把内容输出到 标准输出`（os.Stdout）`，
而 `Fprint` 系列的设计是更通用的：只要目标对象实现了 io.Writer 接口，就可以成为输出目标

比如：

- 文件（*os.File）
- 网络连接（net.Conn）
- 内存缓冲区（bytes.Buffer）
- 标准错误输出（os.Stderr）

| 函数名                        | 说明        | 输出目标                  | 是否支持格式符 |
|----------------------------|-----------|-----------------------|---------|
| `Fprint(w, a...)`          | 输出内容到 `w` | 任意实现了 `io.Writer` 的对象 | 否       |
| `Fprintln(w, a...)`        | 自动加空格和换行  | 任意 `io.Writer`        | 否       |
| `Fprintf(w, format, a...)` | 按格式化输出    | 任意 `io.Writer`        | 是       |

> `fmt.Fprint*` 系列本身不会决定是否覆盖，真正决定覆盖还是追加的，是怎么打开文件的方式（即 os.Create / os.OpenFile 的参数）

| 打开方式       | 行为              | 常用函数                                |
|------------|-----------------|-------------------------------------|
| 覆盖写（清空原内容） | 每次创建新文件，原文件内容清空 | `os.Create()`                       |
| 追加写（保留原内容） | 在文件末尾追加内容       | `os.OpenFile()` + 标志位 `os.O_APPEND` |
| 读写模式       | 同时读写            | `os.OpenFile()` + 多个标志位组合           |

## `fmt` 输入函数

| 功能类型               | 输出目标                  | 常用函数                         | 说明                     |
|--------------------|-----------------------|------------------------------|------------------------|
| **从标准输入读取**        | 标准输入（`os.Stdin`）      | `Scan`, `Scanln`, `Scanf`    | 从控制台读取输入（阻塞等待）         |
| **从自定义 Reader 读取** | 任意实现了 `io.Reader` 的对象 | `Fscan`, `Fscanln`, `Fscanf` | 从文件、网络连接等读取输入          |
| **格式化扫描字符串**       | 从字符串解析数据              | `Sscan`, `Sscanln`, `Sscanf` | 从字符串中提取值（与 Sprintf 相对） |

### scan 控制台输入

**共同点**

- 都会从 标准输入（stdin） 读取数据。
- 所有要接收输入的变量都要传指针（&var），这样函数才能修改变量的值。
- 都返回两个值：
    - 成功读取的项目数
    - 可能的错误（error）

1. `fmt.Scan`：按空白分隔读取

    - 默认用 空格、换行、Tab 等空白字符分隔输入
    - 可以一次输入多个值
    - 如果输入项少于参数个数，会阻塞等待
    - 这种分两行输入也可以，因为换行也被当作空白分隔符

2. `fmt.Scanln`：按行读取（遇到换行就停）
    - 遇到换行符立即停止读取（不会跨行）
    - 如果输入项数量比参数少，会立刻报错（不会等待下一行）

3. `fmt.Scanf`：按格式读取
    - 需要提供输入格式模板，像 Printf 的逆操作
    - 输入格式必须与模板严格匹配（包括空格、符号）
    - 适合需要明确格式的输入

### sscan 字符串输入

Scan、Scanln、Scanf 的非交互式版本

| 对比项    | 控制台输入系列     | 字符串输入系列       |
|--------|-------------|---------------|
| 数据来源   | 用户键盘（stdin） | 已有字符串（string） |
| 函数前缀   | `Scan`      | `Sscan`       |
| 是否阻塞等待 | 是           | 否（立即返回）       |
| 适用场景   | 用户交互输入      | 解析字符串内容       |

1. `fmt.Sscan`：按空白分隔读取字符串
    - 按 空格、换行、Tab 等空白符分隔
    - 和 Scan 基本一样，只是数据源变成字符串
    - 适合解析简单的空格分隔字符串

2. `fmt.Sscanln`：按行读取字符串（遇换行停止）
    - 从字符串的第一行读取，遇到 `\n`（换行）立即停止
    - 第二行内容不会被读取
    - 等价于 `Scanln` 的字符串版本

3. `fmt.Sscanf`：按格式模板读取字符串
    - 输入必须严格匹配格式模板
    - 可像 Printf 那样自定义格式
    - 用于解析固定结构的字符串（如配置、日志、CSV 等）

### fscan 从文件或流读取系列

`Fscan`、`Fscanln`、`Fscanf` 是 Scan 系列的文件/Reader 版本

即从 文件、网络连接、bytes.Buffer 等实现了 `io.Reader` 接口的对象中读取内容

1. `fmt.Fscan`：从 Reader 按空白分隔读取
    - 按空白符（空格、换行、Tab）分隔
    - 可以跨行读取
    - 适合结构化文本文件（如 CSV、日志等）

2. `fmt.Fscanln`：一行一行读取
    - 读完一行就停（遇到换行符）
    - 和 `Scanln` 一样，多余的输入会报错
    - 适合逐行读取的文本文件

3. `fmt.Fscanf`：按格式模板读取
    - 与 `Scanf` 一样，输入必须和格式模板完全匹配
    - 常用于解析配置文件、日志文件等格式化文本

| 函数        | 数据源            | 分隔方式  | 是否跨行   | 是否要求格式 | 常用场景    |
|-----------|----------------|-------|--------|--------|---------|
| `Fscan`   | Reader（文件/网络流） | 空白分隔  | 是      | 否      | 一次读多个值  |
| `Fscanln` | Reader         | 空白分隔  | 否（读一行） | 否      | 逐行读     |
| `Fscanf`  | Reader         | 按格式模板 | 否      | 是      | 解析结构化数据 |

## 其它辅助函数

### 错误格式化 `fmt.Errorf`

创建格式化错误对象（error 类型）的标准方式

```
func Errorf(format string, a ...any) error
```

- 功能：创建一个带格式的错误对象
- 返回值类型：error 接口（等价于 `type error interface { Error() string }`）

```
err := fmt.Errorf("user %s not found", "Tom")
fmt.Println(err)
```

> 这和 fmt.Printf 类似，只不过 Errorf 返回一个 error 对象，不是直接打印

#### 和 `error.New` 区别

| 函数                              | 功能        | 是否支持格式化 | 是否支持包装 `%w` |
|---------------------------------|-----------|---------|-------------|
| `errors.New("msg")`             | 创建固定字符串错误 | 否       | 否           |
| `fmt.Errorf("format", args...)` | 创建格式化错误   | 是       | 是（Go 1.13+） |

#### `%w` 错误包装

搭配 %w —— 错误包装（error wrapping）

fmt.Errorf 的 高级功能 是用 %w 把一个错误包在另一个错误里面（Go 1.13+ 引入）。

```
baseErr := errors.New("连接失败")
wrapErr := fmt.Errorf("初始化失败: %w", baseErr)

fmt.Println(wrapErr) // 初始化失败: 连接失败
```

> 此时 wrapErr 不仅是一个新的错误消息，还保留了原始错误，可以用 errors.Is / errors.As 来判断或提取。

#### 错误链机制

Go 的 errors 包提供了解包方法： `errors.Is(err, target)` 判断错误链中是否包含 target

```
if errors.Is(wrapErr, baseErr) {
    fmt.Println("底层确实是连接失败")
}
```

`errors.As(err, &targetType)`：判断链中是否存在特定类型的错误

```
var pathErr *os.PathError
if errors.As(err, &pathErr) {
    fmt.Println("这是文件路径错误")
}
```

## `fmt.Stringer`

`fmt.Stringer `接口决定了：当用 `fmt.Println()` 或 `%v` 打印某个类型时，它显示成什么样

| 特性         | 说明                                       |
|------------|------------------------------------------|
| **接口类型**   | 任何实现 `String() string` 的类型都满足            |
| **自动调用**   | `fmt.Print` / `fmt.Sprintf` / `%v` 会自动调用 |
| **控制输出格式** | 让结构体打印更友好                                |
| **与调试区分**  | `%#v` 不会调用 `String()`，它输出原始结构体内容         |

### 底层机制（自动调用）

当执行：`fmt.Print(user)`
Go 内部大致做了这样的判断逻辑：

```
if obj, ok := user.(fmt.Stringer); ok {
    fmt.Print(obj.String())
} else {
    fmt.Print(默认格式)
}
```

所以任何类型只要实现了 String() 方法，就能自定义自己的打印样式



> fmt包官方文档地址：https://pkg.go.dev/fmt
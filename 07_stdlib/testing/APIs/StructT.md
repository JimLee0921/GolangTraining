# `testing.T`

`testing.T` 是 Go 执行单元测试中的每一个测试用例的执行上下文，主要用于：

- 控制测试执行流程（子测试、并行运行）
- 记录测试状态（成功、失败、跳过）
- 输出日志
- 管理测试资源（临时目录、环境变量、清理操作）
- 提供超时支持（Deadline）
- 自动传播 context
- 维护测试树层级结构（父子测试）

简单说：`testing.T` 管理一条测试用例的生命周期，每一个 `TestXxx(t *testing.T)` 调用都会获得一个新的 T。

`testing.T` 实现了 `testing.TB` 接口，所以实现自接口的那些方法不再讲解，这里只讲解 `testing.T` 自己的方法

## 专属方法

### 1. t.Run

`t.Run` 是由于创建子测试的方法，这是 `testing.T` 最强大的能力之一，是表格驱动测试的核心机制。
创建的每个子测试有独立的 T，并且上下文隔离，是安全的，因此可以更加精细地控制测试。

```
func (t *T) Run(name string, f func(t *T)) bool
```

- 创建一个名字为 name 的子测试，给它一个新的 `*testing.T `
- 当前测试会同步等待子测试执行结束
- 返回值 bool 表示子测试是否通过（`!t.Failed()`）
- `t.Run` 里的子测试函数可以再 `t.Run`，形成多级子测试树

**注意事项**

1. 循环变量捕获问题：一定要 `c := c`，否则闭包拿到的是同一个地址，全部子测试用的是最后一项。
2. 父测试会等待所有 `t.Run` 执行完才结束，如果里面用 `t.Parallel()`，它会异步并行执行，但父测试仍然会等子测试结束

### 2. t.Parallel

用于标记某个测试（或子测试）可以与同一层级的其它测试并行执行。在一个测试中调用 `t.Parallel()` 之后：

1. 当前测试会登记为并行测试
2. 暂时挂起，直到父测试允许并行阶段开始
3. 和其它同样标记为并行测试的测试一起并发执行

```
func (t *T) Parallel()
```

**注意事项**

- 未调用 `t.Parallel()` 的测试会串行执行，先跑完
- 调用了 `t.Parallel()` 的测试会等待所有非 parallel 的顶层测试执行完毕再一起并行执行
- 不能并行读写共享变量，除非加锁或使用无数据竞争的方式
- parallel 子测试一定记得 `c := c` 重新赋值，否则可能导致数据错乱
- 更多使用场景是在表格驱动测试中多个子测试一起并行执行

### 3. t.Deadline

获取测试的截止时间，也就是返回测试是否超时与超时的时间

```
Deadline() (time.Time, bool)
```

**返回值**

- `time.Time`：当前测试必须结束的绝对时间
- bool：是否存在 deadline（一般通过 `go test -timeout` 进行设置）

> 默认情况下 `go test` 有一个默认超时时间，也会产生 deadline

可以用于动态决定是否跳过某些耗时测试，自适应调节测试规模，也可以和 `Context()` 方法联动


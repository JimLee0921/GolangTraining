# sync/atomic 包

`sync/atomic` 包提供的是无锁的原子操作（原子内存原语，用于实现同步算法），用于在并发环境下对单个变量进行安全、不可分割的读写

> atomic 包的功能需要谨慎使用，要通过通信来共享内存；不要通过共享内存来进行通信

## 对比 Mutex

虽然 Mutex 已经可以保证数据原子性，但是性能成本过高：

```
mu.Lock()
x++
mu.Unlock()
```

- 可能阻塞
- 可能发生 goroutine 且换
- 有锁竞争
- 有调度开销

> 在高频，极其简单的操作下，成本相比太高了

## 原理

atomic 可以左到不加锁、不阻塞、不发生 goroutine 切换，直接使用 CPU 的原子指令，主要原因在并发环境下对一个变量的读、改、写操作不被打断、不产生中间状态、不需要锁

> 只适合单个变量的操作

在 CPU 层面，`x++` 主要分为三步

1. 从内存加载 x
2. x+=1
3. 写回内存

## 能力边界

atomic 主要提供下面几种能力:

- 原子读（Load）
- 原子写（Store）
- 原子加减（Add）
- 原子交换（Swap）
- 原子比较并交换（CAS:compare-and-swap）

atomic 不能用于下面情况：

- 保护多个变量的一致性
- 表达复杂情况
- 代替锁写业务逻辑
- 管理资源声明周期

> atomic 是指令级工具，不是并发结构工具
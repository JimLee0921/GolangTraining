## 引用类型数据传递

对于**引用类型（slice、map、chan、function、interface）**来说，
**它们的值本身是一个指向底层数据结构的引用（指针）**

所以：

* 传过去时，**拷贝的是引用指针**
* 因此函数内部可以修改底层数据（共享）
* 但如果在函数内部重新分配一个新的引用对象，那就只改了副本

## 各种引用数据类型传递

1. slice 数据传递
    - 可以修改底层数据（可见） 因为 slice 拷贝了一个引用，传递的引用和原 slice 都指向同一个底层数组
    - 重新 append（不可见）
        * slice 的结构包含三个字段：`ptr`, `len`, `cap`
        * 传参时这三个字段会被复制
        * `append` 可能触发扩容，生成新的底层数组
        * 所以只修改了副本的 `ptr`、`len`，原变量不变
        * 可以用返回值写回或者传 `*[]int`（指针）
2. map 数据传递
    - 可以直接修改键值对：因为 map 变量内部持有一个指向底层哈希表的指针， 复制 map 时只是复制这个指针，所以修改键值会影响外层
    - 不能重新重新分配
        * `m = make(map[string]int)` 改变了函数内部的 map 引用
        * 外部变量仍然指向旧哈希表
        * 所以外部不受影响
        * 可以直接传入 `*map` 进行重新分配
3. channel 数据传递
    - channel 也是引用类型，拷贝后依然指向同一个通道
    - 因为 channel 的内部实现中，`chan` 变量持有的是一个指针（指向底层 queue）

4. function / interface 的传递（同理）
    - 本质上也都是**内部封装了指针**的引用类型
    - 拷贝 `fn` 只是拷贝函数指针，不会重新创建函数

## 总结

- Go 所有传参都是值传递，没有真正意义的“引用传递
- 引用类型的值里本身包含一个指针，所以修改底层数据会影响外部
- 想要函数能替换引用对象本身，必须返回新值或传指针
- slice/map 并不是传统意义上的指针类型，它们是值语义的引用结构


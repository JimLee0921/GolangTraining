## 函数参数类型传递

Go 中函数参数一律按值传递（pass-by-value）。
差别在于传过去的值究竟是数据本身（值类型），还是一个指向底层数据的引用头部（引用类型）。

## 类型分类

| 类别       | 代表                                             | 传参时拷贝了什么              | 在被调函数里修改后，调用方是否可见                  |
|----------|------------------------------------------------|-----------------------|------------------------------------|
| **值类型**  | `int`、`bool`、`float`、`string`、`struct`、`array` | 数据本身                  | （除非传指针或返回新值）                       |
| **引用类型** | `slice`、`map`、`chan`、`function`、`interface`    | 一个**小的头部值**（内部含指针/状态） | 对底层数据/通道状态的修改可见（但**重绑定变量**对调用方不可见） |

* `string` 从表达上属于值类型（不可变），但是具有特殊性，实现上是指针+长度的只读头部；不能修改底层字节，因此看起来像值

## 注意事项

1. slice append 不可见
    * 现象：被调里 `append` 后，调用方长度没变
    * 方案：返回新的 slice 或 `*[]T`；或提前 `make([]T, 0, bigCap)` 保证不扩容
2. 把 map 形参重新 make
    * 现象：调用方拿到的还是旧 map
    * 方案：直接修改键值；如需整体替换，请**返回新 map** 或传 `*map[K]V`
3. 数组与切片混淆
    * `[N]T` 传参会拷贝整个数组；`[]T` 才是引用头部
    * 方案：要可修改 -> 用 `* [N]T` 或 `[]T`

4. string看起来像引用，但不可变
    * 不能修改底层字节（需要转 `[]byte` 改完再转回）
5. struct 频繁值拷贝 -> 性能差
    * 方案：用指针参数/指针接收者；或将大字段拆到堆并复用

## 总结

| 目标             | 推荐做法                      |
|----------------|---------------------------|
| 只读             | 直接传值（小对象）或引用类型            |
| 修改调用方变量（值类型）   | 传 `*T` 或返回新值让调用方赋回        |
| 修改切片元素         | 直接传 `[]T`                 |
| 修改切片长度（append） | **返回** 新切片 / 传 `*[]T`     |
| 修改整张 map 内容    | 直接传 `map[K]V`             |
| 替换整张 map       | 返回新 map / 传 `*map[K]V`    |
| channel 通信     | 传 `chan T`（不要在函数内 rebind） |
| 性能考虑（大结构）      | 用指针参数/接收者，避免大拷贝           |

> Go 永远是按值传递
> 传值类型就复制数据本身
> 传引用类型就复制指向底层数据的头部，因此能改到同一份底层数据。
> 想在函数里换一整个引用（rebind）让外层也跟着变 -> 要么返回新值，要么传指针。

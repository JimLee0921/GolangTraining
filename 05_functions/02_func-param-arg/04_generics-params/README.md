## 泛型函数参数

## 语法

```go
func Max[T comparable](a, b T) T {
if a > b { return a }
return b
}
```

- T：类型参数（Type parameter）
- `[T comparable]`：约束（constraint），说明 T 必须是可比较类型
- (a, b T)：两个参数类型都是 T
- 返回值类型也为 T
- Go 编译器会根据实参类型自动推断出 T 的类型

## 详解

```go
func FunctionName[T constraint](params T) returnType
```

| 名称           | 含义                                |
|--------------|-----------------------------------|
| `T`          | 类型参数（类似函数的类型形参）                   |
| `constraint` | 限制 T 能取哪些类型（比如 `int`、`float64` 等） |
| `T` 的使用      | 可以作为函数参数、返回值、局部变量类型               |

## 约束

1. any：等价于 interface{}，代表任何类型。
2. comparable： 表示类型必须支持 == 和 !=
3. 可以自己定义一个接口，用作约束

## 泛型与空接口

泛型不等于空接口，它们看起来都能接受任意类型，但本质、编译时行为和性能都完全不同

### 空接口

在没有泛型之前，Go 想写一个“接收任意类型”的函数，常常这么写：

```go
func PrintAny(v interface{}) {
fmt.Println(v)
}
```

这里的 interface{}（或 Go 1.18+ 的 any）表示：不关心具体类型，任何类型都可以传，这样虽然灵活但是失去了类型信息（编译期不再检查类型）
如果要操作只能使用 `v.(int)` 进行类型断言或者用 reflect 去反射出类型

泛型则是 在编译期生成不同类型的代码

```go
func Max[T comparable](a, b T) T {
if a > b { return a }
return b
}
```

编译器会在编译期自动生成相应的版本，比如：

- 当调用 Max(3, 5) -> 生成 int 版本
- 当调用 Max(3.14, 2.71) -> 生成 float64 版本

也就是说：

泛型函数在编译阶段仍然是强类型检查的，编译器不会退化为 interface{}

### 核心区别对比

| 对比项   | 空接口 `interface{}` / `any` | 泛型 `[T any]`                                       |
|-------|---------------------------|----------------------------------------------------|
| 类型检查  | 运行时                       | 编译时                                                |
| 性能    | 较慢（需装箱/反射）                | 与普通类型一致（无反射）                                       |
| 使用灵活度 | 高（完全动态）                   | 高（但需遵守约束）                                          |
| 操作能力  | 只能断言或反射                   | 能直接使用类型运算符（如 `+`、`>`）                              |
| 编译行为  | 单一实现                      | 编译器生成多个专门化版本                                       |
| 示例用途  | `fmt.Println(v ...any)`   | `Max[T comparable](...)`、`SumSlice[T Number](...)` |





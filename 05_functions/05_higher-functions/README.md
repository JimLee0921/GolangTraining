# 函数高级应用

Go 支持函数的高级用法，形成四个核心概念：
高阶函数 -> 闭包 -> 函数工厂 -> 装饰器

## 高阶函数（Higher-Order Function）

### 定义

接收函数作为参数，或返回函数作为结果的函数

### 作用

- 让函数可以操作函数
- 支持将逻辑抽象为可复用的行为单位
- 是函数式编程思想的基础

### 特点

- 参数可以是函数
- 返回值可以是函数
- 编译期类型安全
- 用于算法与逻辑抽象（Map、Filter、Reduce 等）

## 闭包（Closure）

### 定义

闭包是一个函数，它捕获并记住了其外部作用域中的变量，闭包（Closure） 是由函数+外部变量环境组成的可执行单元

当一个函数引用了其外层作用域中的变量，并且这个外层函数已经返回，那么这个内部函数就是一个闭包

### 机制

- 内部函数引用了外层函数的局部变量
- 即使外层函数返回后，这些变量依然存活
- 编译器会将捕获的变量分配到堆上（逃逸分析）

### 意义

- 让函数具备记忆
- 可用于保存状态、延迟执行、配置行为
- 是实现工厂函数与装饰器的核心机制

## 函数工厂（Function Factory）

### 定义

一个返回函数的函数，用于生成带有特定配置或状态的函数，也就是写一个函数，这个函数不直接执行逻辑，
而是制造出另一个可定制的函数

> 普通函数 -> 返回值是数据
> 函数工厂 -> 返回值是函数
> 每次调用工厂函数时，返回的函数都携带了不同的环境（变量状态）

### 机制

- 借助闭包捕获参数
- 每次调用工厂函数都会生成独立的函数实例
- 可视为生产函数的函数

### 与闭包的关系

|        | 闭包          | 函数工厂       |
|--------|-------------|------------|
| 定义     | 函数捕获外部变量的机制 | 返回闭包的高阶函数  |
| 作用     | 让函数记住状态     | 根据配置生成特定函数 |
| 是否依赖闭包 | 是           | 由闭包实现      |
| 是否返回函数 | 可选          | 必然返回函数     |

### 用途

- 日志、验证、计算等按配置生成
- 每个函数实例带有独立参数（状态安全）
- 提升代码复用性与灵活性

## 装饰器（Decorator）

### 定义

一种利用高阶函数和闭包实现的设计模式，接收一个函数作为参数，并返回一个新函数，
在不修改原函数逻辑的前提下，为其添加额外功能，装饰器就是函数的包装器（wrapper function）

### 与函数工厂的关系

| 特征 | 函数工厂     | 装饰器      |
|----|----------|----------|
| 输入 | 普通参数     | 一个函数     |
| 输出 | 新函数      | 增强后的函数   |
| 目的 | 创建新行为    | 增强旧行为    |
| 本质 | **生成函数** | **包裹函数** |
| 实现 | 基于闭包     | 基于闭包     |

> 函数工厂是生产函数，装饰器是改造函数

### 机制

- 接收一个函数作为参数
- 返回一个新函数
- 新函数在调用前后增加逻辑（如日志、缓存、计时）
- 装饰器可以形成链式调用
    - withRecover(withTimer(withLog(square)))
    - 执行顺序：withLog -> withTimer -> withRecover -> square
    - 内层函数最先执行，外层装饰器最晚执行，嵌套太深会影响可读性，可使用组合器（compose）简化

### 用途

- 日志打印（withLog）
- 性能计时（measureTime）
- 中间件（HTTP handler 包装）
- 权限控制（auth wrapper）

## 对比关系

| 概念       | 定义          | 关键作用        | 是否返回函数 | 是否依赖闭包 |
|----------|-------------|-------------|--------|--------|
| **高阶函数** | 操作函数的函数     | 提供函数作为参数/返回 | 可选     | 可选     |
| **闭包**   | 捕获外部变量的函数   | 让函数记住上下文    | 是      | 是      |
| **函数工厂** | 返回函数的高阶函数   | 生成带状态的函数    | 是      | 是      |
| **装饰器**  | 包裹增强函数的高阶函数 | 扩展函数功能      | 是      | 是      |

- 高阶函数：让函数能操作函数
- 闭包：让函数能记住变量
- 函数工厂：让函数能制造函数
- 装饰器：让函数能增强函数

## 函数组合（Function Composition）

### 概念定义

函数组合（Function Composition）是指：将多个函数组合成一个新函数，新函数执行时，前一个函数的输出将作为下一个函数的输入，就是把多个小函数连接成一个大的函数链

数学上常写作：`f ∘ g = f(g(x))`

* 先执行 `g(x)`
* 再执行 `f(结果)`
* 最终得到组合函数 `h(x)`

### 机制

- 传统写法（嵌套）：`result := f(g(h(x)))`

- 函数组合后（声明式）：
    - `composed := Compose(f, g, h)`
    - `result := composed(x)`
- 效果相同，但组合方式更直观、可复用、可组合。

### 通用格式

支持多个函数组合（可变数量）

```go
func Compose[T any](funcs ...func (T) T) func (T) T {
return func (x T) T {
result := x
for i := len(funcs) - 1; i >= 0; i-- { // 从右到左执行
result = funcs[i](result)
}
return result
}
}
```

### Pipe：

如果希望更符合数据流语义，可以使用Pipe（从左到右的组合器）

```go
func Pipe[T any](funcs ...func (T) T) func (T) T {
return func (x T) T {
result := x
for _, fn := range funcs { // 正向执行
result = fn(result)
}
return result
}
}
```

### 与装饰器结合

- 假设有多个装饰器函数：`withLog`，`withTimer`，`withRecover`
- 传统写法：`fn := withRecover(withTimer(withLog(task)))`
- 组合器写法：`fn := Compose(withRecover, withTimer, withLog)(task)`
    - 效果相同，但结构更清晰
    - 组合器自动包裹所有函数

### 应用场景

| 场景         | 示例                                     | 说明          |
|------------|----------------------------------------|-------------|
| **数据流处理**  | `Pipe(filter, transform, output)`      | 串联多个数据操作函数  |
| **中间件链**   | `Compose(auth, log, recover)(handler)` | HTTP 框架常用结构 |
| **装饰器组合**  | `Compose(withLog, withTimer)`          | 多功能包装       |
| **算法链式操作** | `Compose(square, double, add1)`        | 函数式写法替代嵌套   |
| **配置式逻辑**  | 组合策略函数                                 | 动态组合行为      |

### Compose 与 Pipe 的对比

| 项目       | Compose              | Pipe               |
|----------|----------------------|--------------------|
| 执行方向     | 从右到左                 | 从左到右               |
| 适用风格     | 数学函数式                | 数据流式               |
| 示例       | `Compose(f2, f1)(x)` | `Pipe(f1, f2)(x)`  |
| 用于       | 装饰器组合                | 数据处理链              |
| 类似语言中的对应 | Haskell, Scala       | JavaScript, Python |
